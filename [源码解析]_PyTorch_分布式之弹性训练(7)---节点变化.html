<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-cross-origin" />
    <meta name="keywords" content="001_机器学习,006_深度学习,011_分布式机器学习" />
    <meta name="description" content="本文分析如何处理节点变化。即对成员更改作出反应，并使用新的成员来重启所有workers，从而实现弹性训练。" />
    <meta property="og:description" content="本文分析如何处理节点变化。即对成员更改作出反应，并使用新的成员来重启所有workers，从而实现弹性训练。" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[源码解析] PyTorch 分布式之弹性训练(7)---节点变化 - 罗西的思考 - 博客园</title>
    <link rel="icon" id="favicon" href="https://assets.cnblogs.com/favicon_v3_2.ico" type="image/x-icon" />
    <link rel="canonical" href="https://www.cnblogs.com/rossiXYZ/p/15743246.html" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=3DArmf-Or-4qxFZkl3OdynS2Am4I6_pcIbQbRZRdGaM" />
    

    <link id="MainCss" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright.min.css?v=O5zHESxCF0tzyVg01nX06fLeohvC5JYxsLWE4NmQOMg" />
        <link id="highlighter-theme-cnblogs" type="text/css" rel="stylesheet" href="/css/hljs/cnblogs.css?v=5J1NDtbnnIr2Rc2SdhEMlMxD4l9Eydj88B31E7_NhS4" />
    
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright-mobile.min.css?v=Uw1Hg7i9RFPazLAd0cWltL-cniUkUgHHPLh7ZV9ZL9o" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/rossiXYZ/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/rossiXYZ/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/rossiXYZ/wlwmanifest.xml" />
    
    <script type="application/ld&#x2B;json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "@id": "https://www.cnblogs.com/rossiXYZ/p/15743246.html",
      "headline": "[源码解析] PyTorch 分布式之弹性训练(7)---节点变化",
      "description": "[源码解析] PyTorch 分布式之弹性训练(7) 节点变化 0x00 摘要 本文分析如何处理节点变化。即对成员更改作出反应，并使用新的成员来重启所有workers，从而实现弹性训练。 总体思路是和当工作进程失败时的处理一样：相应elastic agent将杀死该节点上的所有工作进程，与其他代理建",
      "image": [
        
      ],
      "author": {
        "@type": "Person",
        "@id": "https://www.cnblogs.com/rossiXYZ/",
        "name": "罗西的思考",
        "url": "https://www.cnblogs.com/rossiXYZ/"
      },
      "publisher": {
        "@type": "Organization",
        "@id": "https://www.cnblogs.com/",
        "name": "博客园",
        "url": "https://www.cnblogs.com/"
      },
      "datePublished": "2021-12-31T14:31:00.0000000&#x2B;08:00",
      "dateModified": "2021-12-31T14:31:00.0000000&#x2B;08:00",
      "wordCount": "39712",
      "isPartOf": {
        "@type": "Blog",
        "@id": "https://www.cnblogs.com/rossiXYZ/",
        "name": "罗西的思考",
        "publisher": {
          "@type": "Organization",
          "@id": "https://www.cnblogs.com/",
          "name": "博客园"
        }
      }
    }
    </script>

    <script>
        var currentBlogId = 556264;
        var currentBlogApp = 'rossiXYZ';
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'LessIsMoreRight';
        var visitorUserId = '';
        var hasCustomScript = false;
        window.cb_enable_mathjax = true;
        window.mathEngine = 0;
        window.codeHighlightEngine = 1;
        window.enableCodeLineNumber = false;
        window.codeHighlightTheme = 'cnblogs';
        window.darkModeCodeHighlightTheme = 'vs2015';
        window.isDarkCodeHighlightTheme = false;
        window.isDarkModeCodeHighlightThemeDark = true;
        window.isDisableCodeHighlighter = false;
        window.enableCodeThemeTypeFollowSystem = false;
        window.enableMacStyleCodeBlock = false;
    </script>
        <script>
            window.currentPostId = 15743246;
            window.currentPostDateAdded = '2021-12-31 14:31';
        </script>
    <script src="https://assets.cnblogs.com/scripts/jquery-3.3.1.min.js"></script>
    <script src="https://cdn-www.cnblogs.com/js/blog-common.min.js?v=wZ-j9lgqsnaTqSE7AdWd3J3j9ENiZHPW0sel6vKY_Mo"></script>
    
</head>
<body class="skin-lessismoreright has-navbar mathjax2">
    <a name="top"></a>
        <div id="imagebar" class="imagebar-mobile imagebar-text-mobile formobile">
                <a href="https://www.doubao.com?channel=cnblogs&amp;source=hw_db_cnblogs&amp;type=lunt&amp;theme=bianc" onclick="countCreativeClicks('M2-字节-豆包')" rel="nofollow">
                    <img src="https://img2024.cnblogs.com/blog/35695/202412/35695-20241201073014811-1847930772.jpg" alt="" onload="countCreativeImpressionsOnMobile('M2-字节-豆包')" />
                    <span id="m2_impression" style="display:none"></span>
                </a>
        </div>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding">                    
                    <a href="https://www.cnblogs.com/" title="开发者的网上家园" role="banner">
                        <img src="//assets.cnblogs.com/logo.svg" alt="博客园logo" />
                    </a>
                </li>               
                <li><a href="https://cnblogs.vip/">会员</a></li>
                <li><a href="https://cnblogs.vip/store">周边</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-q')">博问</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://www.cnblogs.com/cmt/p/18341478">赞助商</a></li>
                <li><a href="https://chat2db-ai.com/" target="_blank" onclick="countClicks('nav', 'skin-navbar-chat2db')">Chat2DB</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search dropdown" action="https://zzk.cnblogs.com/s" method="get" role="search">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="search" tabindex="3" autocomplete="off" />
                        <button id="zzk_search_button" onclick="window.navbarSearchManager.triggerActiveOption()">
                            <img id="search_icon" class="focus-hidden" src="//assets.cnblogs.com/icons/search.svg" alt="搜索" />
                            <img class="hidden focus-visible" src="//assets.cnblogs.com/icons/enter.svg" alt="搜索" />
                        </button>
                        <ul id="navbar_search_options" class="dropdown-menu quick-search-menu">
                            <li tabindex="0" class="active" onclick="zzkSearch(event, document.getElementById('zzk_search_input').value)">
                                <div class="keyword-wrapper">
                                    <img src="//assets.cnblogs.com/icons/search.svg" alt="搜索" />
                                    <div class="keyword"></div>
                                </div>
                                <span class="search-area">所有博客</span>
                            </li>
                                    <li tabindex="1" onclick="zzkBlogSearch(event, 'rossiXYZ', document.getElementById('zzk_search_input').value)">
                                        <div class="keyword-wrapper">
                                            <img src="//assets.cnblogs.com/icons/search.svg" alt="搜索" />
                                            <div class="keyword"></div>
                                        </div>
                                        <span class="search-area">当前博客</span>
                                    </li>
                        </ul>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="//assets.cnblogs.com/icons/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="//assets.cnblogs.com/icons/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="//assets.cnblogs.com/icons/message.svg" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <a id="navbar_lite_mode_indicator" data-current-page="blog" style="display: none" href="javascript:void(0)" alt="简洁模式" title="简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示">
                        <img class="navbar-icon" src="//assets.cnblogs.com/icons/lite-mode-on.svg" alt="简洁模式" />
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="//assets.cnblogs.com/icons/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="https://vip.cnblogs.com/my">会员中心</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>

                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    <div id="page_begin_html">
        

    </div>

    <div id="home">
    <div id="header">
        <div id="blogTitle">
            <div class="title"><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/rossiXYZ">罗西的思考</a>
</div>
<div class="subtitle">一手伸向技术，一手伸向生活</div>

        </div>
        <div id="navigator">
            
<ul id="navList">
    <li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
    <li id="nav_myhome">
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/rossiXYZ/">
首页</a>
</li>
    <li id="nav_newpost">

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
    <li id="nav_contact">
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%BD%97%E8%A5%BF%E7%9A%84%E6%80%9D%E8%80%83">
联系</a></li>
    <li id="nav_rss">
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/rossiXYZ/rss/">
订阅</a></li>
    <li id="nav_admin">
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>

            <div class="blogStats">
                <div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
            </div>
        </div>
    </div>
    <div id="main">
        <div id="mainContent">
            <div class="forFlow">
                <div id="post_detail">
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rossiXYZ/p/15743246.html" title="发布于 2021-12-31 14:31">
    <span role="heading" aria-level="2">[源码解析] PyTorch 分布式之弹性训练(7)---节点变化</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        本文分析如何处理节点变化。即对成员更改作出反应，并使用新的成员来重启所有workers，从而实现弹性训练。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="源码解析-pytorch-分布式之弹性训练7---节点变化">[源码解析] PyTorch 分布式之弹性训练(7)---节点变化</h1>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#源码解析-pytorch-分布式之弹性训练7---节点变化" rel="noopener nofollow">[源码解析] PyTorch 分布式之弹性训练(7)---节点变化</a><ul><li><a href="#0x00-摘要" rel="noopener nofollow">0x00 摘要</a></li><li><a href="#0x01-变化方式" rel="noopener nofollow">0x01 变化方式</a><ul><li><a href="#11-scale-down" rel="noopener nofollow">1.1 Scale-down</a></li><li><a href="#12-scale-up" rel="noopener nofollow">1.2 Scale-up</a></li></ul></li><li><a href="#0x02-节点加入" rel="noopener nofollow">0x02 节点加入</a><ul><li><a href="#21-新节点加入" rel="noopener nofollow">2.1 新节点加入</a></li><li><a href="#22-处理-join-操作" rel="noopener nofollow">2.2 处理 Join 操作</a><ul><li><a href="#221-run处理" rel="noopener nofollow">2.2.1 run处理</a></li><li><a href="#222-join操作" rel="noopener nofollow">2.2.2 Join操作</a></li><li><a href="#223-等待业务操作" rel="noopener nofollow">2.2.3 等待业务操作</a></li></ul></li><li><a href="#23-agent-处理" rel="noopener nofollow">2.3 Agent 处理</a><ul><li><a href="#231-检查等待列表" rel="noopener nofollow">2.3.1 检查等待列表</a></li><li><a href="#233-重启worker组" rel="noopener nofollow">2.3.3 重启worker组</a><ul><li><a href="#2331-_stop_workers" rel="noopener nofollow">2.3.3.1 _stop_workers</a></li><li><a href="#2332-_shutdown" rel="noopener nofollow">2.3.3.2 _shutdown</a></li><li><a href="#2333-关闭上下文" rel="noopener nofollow">2.3.3.3 关闭上下文</a></li><li><a href="#2334-_initialize_workers" rel="noopener nofollow">2.3.3.4 _initialize_workers</a></li><li><a href="#2335-_rendezvousjoinop" rel="noopener nofollow">2.3.3.5 _RendezvousJoinOp</a></li><li><a href="#2336-_add_to_participants" rel="noopener nofollow">2.3.3.6 _add_to_participants</a></li></ul></li></ul></li></ul></li><li><a href="#0x03-节点离开" rel="noopener nofollow">0x03 节点离开</a><ul><li><a href="#31-处理机制" rel="noopener nofollow">3.1 处理机制</a></li><li><a href="#32-如何模拟" rel="noopener nofollow">3.2 如何模拟</a></li><li><a href="#33-如何处理" rel="noopener nofollow">3.3 如何处理</a><ul><li><a href="#331-重启" rel="noopener nofollow">3.3.1 重启</a></li><li><a href="#332-停止" rel="noopener nofollow">3.3.2 停止</a></li></ul></li></ul></li><li><a href="#0xff-参考" rel="noopener nofollow">0xFF 参考</a></li></ul></li></ul></div><p></p>
<h2 id="0x00-摘要">0x00 摘要</h2>
<p>本文分析如何处理节点变化。即对成员更改作出反应，并使用新的成员来重启所有workers，从而实现弹性训练。</p>
<p>总体思路是和当工作进程失败时的处理一样：相应elastic agent将杀死该节点上的所有工作进程，与其他代理建立会合（rendezvous），并使用新的会合（rendezvous）信息重新启动所有工作进程。</p>
<p>弹性训练系列文章如下：</p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15718043.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(1) --- 总体思路</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15725911.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(2)---启动&amp;单节点流程</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15728861.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(3)---代理</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15735170.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(4)---Rendezvous 架构和逻辑</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15739391.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(5)---Rendezvous 引擎</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15743162.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(6)---监控/容错</a></p>
<h2 id="0x01-变化方式">0x01 变化方式</h2>
<p>节点变化有两点方式。</p>
<h3 id="11-scale-down">1.1 Scale-down</h3>
<p>节点离开（scale-down）的处理如下：</p>
<ul>
<li>当Scale down事件发生时，rendezvous将不会通知 torchelastic agent。</li>
<li>torchelastic agent 自己会监控到有进程错误，从而进行处理。</li>
<li>如果TE agent以<code>max_restarts=0</code>配置启动，它依赖于底层调度程序来处理作业重新启动。</li>
<li>如果<code>max_restarts&gt;0</code>，TE代理将终止workers并开始新一轮rendezvous。
<ul>
<li>代理得到离开的通知，于是现有workers（所有节点上的）都全部停止。</li>
<li>这些workers将形成一个新的“WorkerGroup”，所有worker都将以新的<code>RANK</code> 和  <code>WORLD_SIZE</code> 运行。</li>
</ul>
</li>
</ul>
<h3 id="12-scale-up">1.2 Scale-up</h3>
<p>节点加入（scale-up）的处理如下：</p>
<ul>
<li>当Scale up事件发生时，新节点被提交到作业，torchelastic rendezvous将检测到有新节点试图加入。
<ul>
<li>如果rendezvous已经达到最多节点数，新节点将不会添加到等待列表，因为已经满了，所以没有必要拆除已经完全体的rendezvous。新节点将一直等待直到超时（默认为600秒）。</li>
<li>新节点将定期检查参与节点数目。如果数目变为小于max_nodes，等待节点将被加入到等待列表中。否则它将在600秒之后超时。</li>
</ul>
</li>
<li>当代理决定处理 Scale up时：
<ul>
<li>torchelastic rendezvous将停止所有workers并执行新一轮的 re-rendezvous。</li>
<li>这些workers（现有以及新加入的）将形成一个新的“WorkerGroup”，所有worker都将以新的<code>RANK</code> 和  <code>WORLD_SIZE</code> 运行。</li>
</ul>
</li>
</ul>
<p>注：scale up发生时，<code>max_restarts</code> 将不会减少。</p>
<h2 id="0x02-节点加入">0x02 节点加入</h2>
<h3 id="21-新节点加入">2.1 新节点加入</h3>
<p>假设目前已经有了一个弹性训练集群正在运行，弹性区间为 (<code>min=1</code>, <code>max=4</code>)。目前已经有2个节点在运行，用户想启动第三个节点，于是使用如下方法启动一个新进程。</p>
<pre><code class="language-python">python -m torch.distributed.run
        --nnodes=1:4
        --nproc_per_node=$NUM_TRAINERS
        --rdzv_id=$JOB_ID
        --rdzv_backend=c10d
        --rdzv_endpoint=$HOST_NODE_ADDR
        YOUR_TRAINING_SCRIPT.py (--arg1 ... train script args...)
</code></pre>
<p>新进程会启动一个代理。代理经过一系列操作，调用 next_rendezvous，其中启动一个 ExitOp，一个 JoinOp 。</p>
<pre><code class="language-python">def next_rendezvous(self) -&gt; Tuple[Store, int, int]:
    exit_op = _RendezvousExitOp()
    join_op = _RendezvousJoinOp()
    
    self._op_executor.run(exit_op, deadline)
    self._op_executor.run(join_op, deadline)    
</code></pre>
<h3 id="22-处理-join-操作">2.2 处理 Join 操作</h3>
<p>以下操作是在 _DistributedRendezvousOpExecutor 之中。</p>
<p>有了前文分析，我们知道，<u>业务流程是 run 调用 Join 算子来分析出来下一个 Action，然后根据 Action 来执行对应的业务操作</u>。</p>
<h4 id="221-run处理">2.2.1 run处理</h4>
<p><code>_DistributedRendezvousOpExecutor.run</code> 函数实现了基础逻辑，就是依据 action 类型进行各种操作。对于我们示例，state_handler 就是_RendezvousJoinOp。</p>
<pre><code class="language-python">    def run(
        self, state_handler: Callable[[_RendezvousContext, float], _Action], deadline: float
    ) -&gt; None:
        """See base class."""
        action = None

        while action != _Action.FINISH: # 一直循环，直到结束
            
            # 这里很重要，在所有node之间做信息同步
            has_set = self._state_holder.sync() # 因为最新状态在 rendezvous。
            self._state = self._state_holder.state
            # 利用最新状态构建了 ctx
            ctx = _RendezvousContext(self._node, self._state, self._settings)

            # Determine the next action to take based on the current state of
            # the rendezvous.
            action = state_handler(ctx, deadline) # 调用_RendezvousJoinOp，决定下一个操作

            # 省略后续部分
</code></pre>
<h4 id="222-join操作">2.2.2 Join操作</h4>
<p>因为之前做了同步，所以这里的ctx就包括了最新的state，这就是Rendezvous的全局状态。因为此时，Rendezvous 已经结束了，所以 state 的状态是 complete，进入如下流程，返回 _Action.ADD_TO_WAIT_LIST。</p>
<pre><code class="language-python">    if state.complete:
        # If we are here, it means we are not part of the rendezvous. In
        # case the rendezvous has capacity for additional participants add
        # ourself to the wait list for the next round.
        if len(state.participants) &lt; ctx.settings.max_nodes: # 如果当前节点数目小于最大配置
            if ctx.node not in state.wait_list: # 如果当前node不在等待列表之中
                return _Action.ADD_TO_WAIT_LIST  # 发送一个等待action
</code></pre>
<p>总体代码如下：</p>
<pre><code class="language-python">class _RendezvousJoinOp:
    """Represents a rendezvous join operation."""

    def __call__(self, ctx: _RendezvousContext, deadline: float) -&gt; _Action:
        state = ctx.state # 从上下文之中提取 _RendezvousState 状态

        # A closed rendezvous means that it no longer accepts new nodes.
        if state.closed:
            return _Action.ERROR_CLOSED # 如果已经结束，就返回 _Action.ERROR_CLOSED

        is_participant = ctx.node in state.participants # 看看是参与者

        # If we are part of the rendezvous and it is already complete there is
        # no further action to take.
        if state.complete and is_participant: # 如果是参与者且状态结束，就返回 _Action.FINISH
            return _Action.FINISH

        now = time.monotonic()
        if now &gt; deadline: # 如果已经超时
            rollback_period = 5  # 5 seconds

            # If we still have time to rollback (a short period on top of the
            # operation deadline), try to remove ourself from the rendezvous.
            # It is okay if we can't though as our keep-alive will eventually
            # expire.
            if now &lt;= deadline + rollback_period: # 如果还有时间来 rollback
                # If we are part of the rendezvous, it means we couldn't find
                # enough participants to complete it on time.
                if is_participant: # 已经是参与者了
                    return _Action.REMOVE_FROM_PARTICIPANTS # 需要从参与者列表移除
                # If we are in the wait list, it means we couldn't wait till the
                # next round of the rendezvous.
                if ctx.node in state.wait_list: # 已经在等待列表之中
                    return _Action.REMOVE_FROM_WAIT_LIST # 需要从等待列表移除
            return _Action.ERROR_TIMEOUT # 返回超时

        if state.complete: # 如果 rendezvous 已经结束
            # If we are here, it means we are not part of the rendezvous. In
            # case the rendezvous has capacity for additional participants add
            # ourself to the wait list for the next round.
            if len(state.participants) &lt; ctx.settings.max_nodes: # 如果还没有达到最大节点数
                if ctx.node not in state.wait_list: # 如果当前node不在等待列表之中
                    return _Action.ADD_TO_WAIT_LIST # 就加入到等待列表，发送一个等待action
        elif is_participant: # 如果已经在参与者列表
            # If the rendezvous has enough number of participants including us,
            # check whether we have passed the rendezvous deadline. If yes,
            # complete it.
            if len(state.participants) &gt;= ctx.settings.min_nodes: # 如果达到了最小节点数
                if cast(datetime, state.deadline) &lt; datetime.utcnow(): # 如果达到了超时
                    return _Action.MARK_RENDEZVOUS_COMPLETE # 标示 rendezvous 已经结束
        else: # 否则就直接加入到参与者
            # The rendezvous is not complete yet and we are not part of it. Try
            # to join.
            return _Action.ADD_TO_PARTICIPANTS

        if _should_keep_alive(ctx): # 如果需要保持心跳，就返回 _Action.KEEP_ALIVE
            return _Action.KEEP_ALIVE

        # At this point either the rendezvous is not complete, but we are part
        # of it, which means we have to wait for other participants to join; or
        # the rendezvous is complete, but we are not part of it, which means we
        # have to wait for the next round.
        return _Action.SYNC # 否则返回同步状态 _Action.SYNC
</code></pre>
<h4 id="223-等待业务操作">2.2.3 等待业务操作</h4>
<p>_DistributedRendezvousOpExecutor 之中，run 函数实现了基础逻辑，就是依据 action 类型进行各种操作。</p>
<pre><code class="language-python">    def run(
        self, state_handler: Callable[[_RendezvousContext, float], _Action], deadline: float
    ) -&gt; None:
        """See base class."""
        action = None

        while action != _Action.FINISH: # 一直循环，直到结束
     
            # 这里很重要，在所有node之间做信息同步
            has_set = self._state_holder.sync() # 因为最新状态在 rendezvous。
            self._state = self._state_holder.state
					  # 使用最新state构建ctx
            ctx = _RendezvousContext(self._node, self._state, self._settings)

            # Determine the next action to take based on the current state of
            # the rendezvous.
            action = state_handler(ctx, deadline) # 调用_RendezvousJoinOp，决定下一个操作，这里得到了 _Action.ADD_TO_WAIT_LIST

            if action == _Action.SYNC:
                _delay(seconds=1)
            else:
                if action == _Action.KEEP_ALIVE:
                    self._keep_alive()
                elif action == _Action.ADD_TO_WAIT_LIST: # 从 Join 算子得到了_Action.ADD_TO_WAIT_LIST
                    self._add_to_wait_list() # 进行业务逻辑
                # 省略其他action

                # Attempt to sync our changes back to other nodes.
                self._state_holder.mark_dirty() # 同步回其他节点
</code></pre>
<p>具体处理等待操作就是加入到等待列表。</p>
<pre><code class="language-python">def _add_to_wait_list(self) -&gt; None:
    self._state.wait_list.add(self._node)
    self._keep_alive()
</code></pre>
<p>我们回忆一下 <code>_RendezvousState</code>。_RendezvousState 是rendezvous的状态。是动态信息。</p>
<ul>
<li>round：Rendezvous的当前轮次</li>
<li>complete：一个布尔值，指示rendezvous当前一轮是否完成了。</li>
<li>deadline：截止时间，如果如果当前轮次一直在等待节点加入，如果这个参数设置了，就是等待的截至时间。</li>
<li>closed：一个布尔值，指示rendezvous是否结束了。</li>
<li>participants：字典，存放<u>参与者</u>和它们对应ranks。</li>
<li>wait_list：set结构，存放<u>等待参与下一轮rendezvous操作的一组节点</u>。</li>
<li>last_heartbeats：字典，包含每个节点上次心跳时间。</li>
</ul>
<pre><code class="language-python">class _RendezvousState:
    round: int
    complete: bool
    deadline: Optional[datetime]
    closed: bool
    participants: Dict[_NodeDesc, int] # 参与者，未来会用到的成员变量
    wait_list: Set[_NodeDesc]  # 等待者，这里用到的成员变量
    last_heartbeats: Dict[_NodeDesc, datetime]

    def __init__(self) -&gt; None:
        self.round = 0
        self.complete = False
        self.deadline = None
        self.closed = False
        self.participants = {}
        self.wait_list = set() # 这里用到的成员变量
        self.last_heartbeats = {}
</code></pre>
<p>目前逻辑如下：</p>
<ol>
<li>启动一个新 worker。此时下图右侧上方的 _RendezvousState 之中，wait_list 为空。</li>
<li>调用 next_rendezvous，发起新一轮 rendezvous。</li>
<li>_RendezvousJoinOp 内部运行，生成 ADD_TO_WAIT_LIST。</li>
<li>executor . run 内部运行 _add_to_wait_list。</li>
<li>往 wait_list 添加一个新的 node。此时下图右侧上方的 _RendezvousState 之中，wait_list 多了一个 1。</li>
</ol>
<pre><code class="language-python">  python -m torch.distributed.run             +-------------------------+     +
      --nnodes=xxx TRAINING_SCRIPT.py         | _RendezvousState        |     |
                 +                            |                         |     |
                 |                            |    participants = [1,2] |     |
                 | 1                          |                         |     |
                 v                            |    wait_list = []       |     |
          next_rendezvous                     |                         |     |
                 +                            +------------+------------+     |
                 | 2                                       |                  |
                 |                                         |                  |
                 v                                         |                  |
+----------------+-----------------------+                 |                  |
| _op_executor.run(_RendezvousJoinOp)    |                 |                  |
|           +              +             |                 |                  |
|           |              | 3           |                 |                  |
|           |              |             |                 |                  |
|           |              v             |                 |                  |
|           |   _Action.ADD_TO_WAIT_LIST |                 v                  |
|           |              +             |                                    |
|           |              |             |    +--------------------------+    |
|           +&lt;-------------+             |    | _RendezvousState         |    |
|           |                            |    |                          |    |
|           |                            |    |    participants = [1,2]  |    |
|           v       4                    | 5  |                          |    |
|      self._add_to_wait_list() +----------------&gt; wait_list = [3]       |    |
|                                        |    |                          |    |
+----------------------------------------+    +--------------------------+    |
                                                                              |
                                                                              v

                                                                         Timeline
</code></pre>
<h3 id="23-agent-处理">2.3 Agent 处理</h3>
<p>_DistributedRendezvousOpExecutor . run 处理之后，操作回到了代理之中。代理主循环之中，程序会进入 while 循环，然后通过 _monitor_workers 定期轮训用户程序运行情况，依据情况作出判断。</p>
<pre><code class="language-python">    def _invoke_run(self, role: str = DEFAULT_ROLE) -&gt; RunResult:
        # NOTE: currently only works for a single role

        spec = self._worker_group.spec
        role = spec.role

        self._initialize_workers(self._worker_group) # 启动worker
        monitor_interval = spec.monitor_interval
        rdzv_handler = spec.rdzv_handler

        while True:
            assert self._worker_group.state != WorkerState.INIT
            # 定期监控
            time.sleep(monitor_interval)
            # 监控客户程序运行情况
            run_result = self._monitor_workers(self._worker_group)
            state = run_result.state # 进程运行情况
            self._worker_group.state = state

            if state == WorkerState.SUCCEEDED:
                # 程序正常结束
                self._exit_barrier()
                return run_result
            elif state in {WorkerState.UNHEALTHY, WorkerState.FAILED}:
                # 程序出错
                if self._remaining_restarts &gt; 0: # 重试
                    self._remaining_restarts -= 1
                    self._restart_workers(self._worker_group)
                else:
                    self._stop_workers(self._worker_group) # 重试次数达到，结束workers
                    self._worker_group.state = WorkerState.FAILED
                    self._exit_barrier()
                    return run_result
            elif state == WorkerState.HEALTHY:
								# 程序正常运行
                # 节点成员关系有变化，比如scale up
                # membership changes do not count as retries
                num_nodes_waiting = rdzv_handler.num_nodes_waiting()
                group_rank = self._worker_group.group_rank
                # 如果有新的节点在waiting，就重启所有workers
                if num_nodes_waiting &gt; 0:
                    self._restart_workers(self._worker_group)
            else:
                raise Exception(f"[{role}] Worker group in {state.name} state")
</code></pre>
<p>所以，<strong>代理定期运行 _monitor_workers 监控worker运行情况才是关键</strong>。run_result.state 是进程运行情况，当状态是 WorkerState.HEALTHY，说明原有程序正常运行，接下来看看节点成员关系是否有变化。</p>
<p>调用 rdzv_handler.num_nodes_waiting() 拿到等待列表数目，如果有新的节点在waiting，就说明有新的节点试图加入集群，这时就会发生一个Re-rendezvous。代理将重启所有workers。重启时候，会把等待列表中的节点加入到参与列表之中。我们依次看看如何处理。</p>
<h4 id="231-检查等待列表">2.3.1 检查等待列表</h4>
<p>处理时候，首先会调用 num_nodes_waiting 看看还有多少节点在等待，具体是看看 state.wait_list 的长度。我们通过之前 Join 操作知道，如果有新节点，会插入到这个列表之中。</p>
<p>num_nodes_waiting 方法的作用是 返回在 rendezvous barrier 上等待的节点数目（这些节点不会在当前工作组被包括）。调用者应该周期调用这个方法，来确定是否有新节点等候加入当前工作组，因此需要调用<code>next_rendezvous()</code> 来提交他们。</p>
<pre><code class="language-python">def num_nodes_waiting(self) -&gt; int:
    """See base class."""
    with self._heartbeat_lock:
        self._state_holder.sync()

        return len(self._state_holder.state.wait_list)
</code></pre>
<p>目前逻辑如下：</p>
<ol>
<li>启动一个新 worker。</li>
<li>调用 next_rendezvous，发起新一轮 rendezvous。</li>
<li>_RendezvousJoinOp 内部运行，生成 ADD_TO_WAIT_LIST。</li>
<li>executor.run 内部运行 _add_to_wait_list。</li>
<li>往 wait_list 添加一个新的 node。</li>
<li>Agent 之中，定期（比如 30S）运行一次 _monitor_workers，获取worker 子进程状态。</li>
<li>如果是 HEALTHY，则调用num_nodes_waiting 获取 wait_list 个数。</li>
<li>如果 wait_list 之中等待节点数目大于 0，则：</li>
<li>调用 _restart_workers 重启进程组。</li>
</ol>
<pre><code class="language-python">  python -m torch.distributed.run             +-------------------------+     +
      --nnodes=xxx TRAINING_SCRIPT.py         | _RendezvousState        |     |
                 +                            |                         |     |
                 |                            |    participants = [1,2] |     |
                 | 1                          |                         |     |
                 v                            |    wait_list = []       |     |
          next_rendezvous                     |                         |     |
                 +                            +------------+------------+     |
                 | 2                                       |                  |
                 |                                         |                  |
                 v                                         |                  |
+----------------+-----------------------+                 |                  |
| _op_executor.run(_RendezvousJoinOp)    |                 |                  |
|           +              +             |                 |                  |
|           |              | 3           |                 |                  |
|           |              |             |                 |                  |
|           |              v             |                 |                  |
|           |   _Action.ADD_TO_WAIT_LIST |                 v                  |
|           |              +             |                                    |
|           |              |             |    +--------------------------+    |
|           +&lt;-------------+             |    | _RendezvousState         |    |
|           |                            |    |                          |    |
|           |                            |    |    participants = [1,2]  |    |
|           v       4                    | 5  |                          |    |
|      self._add_to_wait_list() +----------------&gt; wait_list = [3]       |    |
|                                        |    |                          |    |
+----------------------------------------+    +------------+-------------+    |
                                                           |                  |
+----------------------------------------+                 |                  |
| agent._invoke_run                      |                 |                  |
|                                        |                 |                  |
|                                        |                 |                  |
|        _monitor_workers Every 30S      |                 |                  |
|                +                       |                 |                  |
|                | 6                     |                 |                  |
|                |                       |                 v                  |
|                v                       |                                    |
|         WorkerState.HEALTHY            |     +--------------------------+   |
|                +                       |     | _RendezvousState         |   |
|                |                       |     |                          |   |
|                | 7                     |     |     participants = [1,2] |   |
|                v                       |  8  |                          |   |
|        num_nodes_waiting   &lt;--------------------&gt;  wait_list = [3]      |   |
|                +                       |     |                          |   |
|                | 9                     |     |                          |   |
|                |                       |     +--------------------------+   |
|                v                       |                                    |
|        _restart_workers                |                                    v
|                                        |
+----------------------------------------+                               Timeline
</code></pre>
<h4 id="233-重启worker组">2.3.3 重启worker组</h4>
<p>如果等待列表之中有节点，就会重启workers。我们走一下这个流程。</p>
<pre><code class="language-python">@prof
def _restart_workers(self, worker_group: WorkerGroup) -&gt; None:
    """
    Restarts (stops, rendezvous, starts) all local workers in the group.
    """

    role = worker_group.spec.role
    self._stop_workers(worker_group)
    worker_group.state = WorkerState.STOPPED
    self._initialize_workers(worker_group)
</code></pre>
<h5 id="2331-_stop_workers">2.3.3.1 _stop_workers</h5>
<p>首先会停止目前 workers，代码在torch/distributed/elastic/agent/server/local_elastic_agent.py。</p>
<pre><code class="language-python">@prof
def _stop_workers(self, worker_group: WorkerGroup) -&gt; None:
    self._shutdown()
</code></pre>
<h5 id="2332-_shutdown">2.3.3.2 _shutdown</h5>
<p>_shutdown 就是让上下文关闭。</p>
<pre><code class="language-python">def _shutdown(self) -&gt; None:
    if self._pcontext:
        self._pcontext.close()
</code></pre>
<h5 id="2333-关闭上下文">2.3.3.3 关闭上下文</h5>
<p>在 MultiprocessContext 之中，close 方法是关闭所有子进程，然后等待其全部停止。</p>
<pre><code class="language-python">    def _close(self) -&gt; None:
        if self._pc:
            for proc in self._pc.processes:
                proc.terminate()
                proc.join()
</code></pre>
<h5 id="2334-_initialize_workers">2.3.3.4 _initialize_workers</h5>
<p>当关闭了所有当前运行的子进程之后，会重新全部初始化。</p>
<pre><code class="language-python">@prof
def _initialize_workers(self, worker_group: WorkerGroup) -&gt; None:
    r"""
    Starts a fresh set of workers for the worker_group.
    Essentially a rendezvous followed by a start_workers.

    The caller should first call ``_stop_workers()`` to stop running workers
    prior to calling this method.

    Optimistically sets the state of the worker group that
    just started as ``HEALTHY`` and delegates the actual monitoring
    of state to ``_monitor_workers()`` method
    """
    role = worker_group.spec.role

    # TODO after stopping workers, wait at least monitor_interval*2 for
    # workers on different nodes to fail on a collective op before waiting
    # on the rdzv barrier, this way we ensure that nodes enter rdzv
    # at around the same time and reduce false positive rdzv timeout errors
    self._rendezvous(worker_group)

    worker_ids = self._start_workers(worker_group)
    for local_rank, w_id in worker_ids.items():
        worker = worker_group.workers[local_rank]
        worker.id = w_id

    worker_group.state = WorkerState.HEALTHY
</code></pre>
<p>_rendezvous经过一系列操作，调用 next_rendezvous，在其中启动一个 ExitOp，一个 JoinOp 。</p>
<pre><code class="language-python">def next_rendezvous(self) -&gt; Tuple[Store, int, int]:

    exit_op = _RendezvousExitOp()
    join_op = _RendezvousJoinOp()
    
    self._op_executor.run(exit_op, deadline)
    self._op_executor.run(join_op, deadline)    
</code></pre>
<h5 id="2335-_rendezvousjoinop">2.3.3.5 _RendezvousJoinOp</h5>
<p>我们又回来了，这是新一轮 Rendezvous 操作。<code>_DistributedRendezvousOpExecutor</code> 之中，run 函数实现了基础逻辑，就是依据 action 类型进行各种操作。对于我们示例，<code>state_handler</code> 就是<code>_RendezvousJoinOp</code>。</p>
<pre><code class="language-python">def run(
    self, state_handler: Callable[[_RendezvousContext, float], _Action], deadline: float
) -&gt; None:
    """See base class."""
    action = None

    while action != _Action.FINISH:
        # Reads or writes the latest rendezvous state shared by all nodes in
        # the rendezvous. Note that our local changes might get overridden
        # by another node if that node synced its changes before us.
        has_set = self._state_holder.sync()
        self._state = self._state_holder.state
        ctx = _RendezvousContext(self._node, self._state, self._settings)

        # Determine the next action to take based on the current state of
        # the rendezvous.
        # 调用到_RendezvousJoinOp，大家可以过一下 _RendezvousJoinOp 代码，发现此时将返回 ADD_TO_PARTICIPANTS
        action = state_handler(ctx, deadline) 

        if action == _Action.SYNC:
            # Delay the execution by one second to avoid overloading the
            # backend if we are asked to poll for state changes.
            _delay(seconds=1)
        else:
            if action == _Action.KEEP_ALIVE:
                self._keep_alive()
            elif action == _Action.ADD_TO_PARTICIPANTS: # 运行到这里
                self._add_to_participants()
            elif action == _Action.ADD_TO_WAIT_LIST:
                self._add_to_wait_list()
            elif action == _Action.REMOVE_FROM_PARTICIPANTS:
                self._remove_from_participants()
            elif action == _Action.REMOVE_FROM_WAIT_LIST:
                self._remove_from_wait_list()
            elif action == _Action.MARK_RENDEZVOUS_COMPLETE:
                self._mark_rendezvous_complete()
            elif action == _Action.MARK_RENDEZVOUS_CLOSED:
                self._mark_rendezvous_closed()

            # Attempt to sync our changes back to other nodes.
            self._state_holder.mark_dirty()
</code></pre>
<p>这次会生成 ADD_TO_PARTICIPANTS。</p>
<pre><code class="language-python">class _RendezvousJoinOp:
    """Represents a rendezvous join operation."""

    def __call__(self, ctx: _RendezvousContext, deadline: float) -&gt; _Action:
        state = ctx.state # 从上下文之中提取 _RendezvousState 状态

        # A closed rendezvous means that it no longer accepts new nodes.
        if state.closed:
            return _Action.ERROR_CLOSED # 如果已经结束，就返回 _Action.ERROR_CLOSED

        is_participant = ctx.node in state.participants # 看看是参与者

        # If we are part of the rendezvous and it is already complete there is
        # no further action to take.
        if state.complete and is_participant: # 如果是参与者且状态结束，就返回 _Action.FINISH
            return _Action.FINISH

        now = time.monotonic()
        if now &gt; deadline: # 如果已经超时
            rollback_period = 5  # 5 seconds

            # If we still have time to rollback (a short period on top of the
            # operation deadline), try to remove ourself from the rendezvous.
            # It is okay if we can't though as our keep-alive will eventually
            # expire.
            if now &lt;= deadline + rollback_period: # 如果还有时间来 rollback
                # If we are part of the rendezvous, it means we couldn't find
                # enough participants to complete it on time.
                if is_participant: # 已经是参与者了
                    return _Action.REMOVE_FROM_PARTICIPANTS # 需要从参与者列表移除
                # If we are in the wait list, it means we couldn't wait till the
                # next round of the rendezvous.
                if ctx.node in state.wait_list: # 已经在等待列表之中
                    return _Action.REMOVE_FROM_WAIT_LIST # 需要从等待列表移除
            return _Action.ERROR_TIMEOUT # 返回超时

        if state.complete: # 如果 rendezvous 已经结束
            # If we are here, it means we are not part of the rendezvous. In
            # case the rendezvous has capacity for additional participants add
            # ourself to the wait list for the next round.
            if len(state.participants) &lt; ctx.settings.max_nodes: # 如果还没有达到最大节点数
                if ctx.node not in state.wait_list: # 如果当前node不在等待列表之中
                    return _Action.ADD_TO_WAIT_LIST # 就加入到等待列表，发送一个等待action
        elif is_participant: # 如果已经在参与者列表
            # If the rendezvous has enough number of participants including us,
            # check whether we have passed the rendezvous deadline. If yes,
            # complete it.
            if len(state.participants) &gt;= ctx.settings.min_nodes: # 如果达到了最小节点数
                if cast(datetime, state.deadline) &lt; datetime.utcnow(): # 如果达到了超时
                    return _Action.MARK_RENDEZVOUS_COMPLETE # 标示 rendezvous 已经结束
        else: # 否则就直接加入到参与者
            # The rendezvous is not complete yet and we are not part of it. Try
            # to join.
            return _Action.ADD_TO_PARTICIPANTS

        if _should_keep_alive(ctx): # 如果需要保持心跳，就返回 _Action.KEEP_ALIVE
            return _Action.KEEP_ALIVE

        # At this point either the rendezvous is not complete, but we are part
        # of it, which means we have to wait for other participants to join; or
        # the rendezvous is complete, but we are not part of it, which means we
        # have to wait for the next round.
        return _Action.SYNC # 否则返回同步状态 _Action.SYNC
</code></pre>
<h5 id="2336-_add_to_participants">2.3.3.6 _add_to_participants</h5>
<p>引擎收到 ADD_TO_PARTICIPANTS 之后，会调用 _add_to_participants 从 wait_list 移除节点，插入到 participants。</p>
<pre><code class="language-python">def _add_to_participants(self) -&gt; None:
    log.debug(
        f"The node '{self._node}' added itself to the participants of round "
        f"{self._state.round} of the rendezvous '{self._settings.run_id}'. Pending sync."
    )

    state = self._state
    state.wait_list.remove(self._node) # 移除节点

    # The ranks of the participants will be set once the rendezvous is
    # complete.
    state.participants[self._node] = 0 # 重新插入

    self._keep_alive()

    if len(state.participants) == self._settings.min_nodes:
        state.deadline = datetime.utcnow() + self._settings.timeout.last_call

    if len(state.participants) == self._settings.max_nodes:
        self._mark_rendezvous_complete()
</code></pre>
<p>我们这次从 _restart_workers 开始绘制。</p>
<ol>
<li>调用 _stop_workers 来关闭worker子进程。此时下图右侧上方 _RendezvousState之中，participants=[1,2]。</li>
<li>通过 MultiprocessContext.close() 完成关闭操作。</li>
<li>通过 _initialize_workers 重新初始化 worker。</li>
<li>调用 next_rendezvous 完成新的同步操作。</li>
<li>_RendezvousJoinOp 这次返回ADD_TO_PARTICIPANTS。</li>
<li>调用 _add_to_participants 进行状态切换。</li>
<li>wait_list 之中的Node被移动到 participants。此时下图右侧上方 _RendezvousState之中，participants=[1,2,3]。</li>
</ol>
<pre><code class="language-python">                         +-----------------------------+   +------------------------+  |
                         |  agent._invoke_run          |   | _RendezvousState       |  |
                         |                             |   |                        |  |
                         |       _restart_workers      |   |   participants = [1,2] |  |
                         |              +              |   |                        |  |
+----------------------+ |              |              |   |   wait_list = [3]      |  |
| MultiprocessContext  | |              | 1            |   |                        |  |
|                      | | 2            v              |   +------------------------+  |
|        close()  &lt;-----------+  _stop_workers         |                               |
|                      | |              +              |                               |
+----------------------+ |              |              |                               |
                         |              | 3            |                               |
                         |              v              |                               |
                         |     _initialize_workers     |                               |
                         |              +              |                               |
                         |              |              |                               |
                         +-----------------------------+                               |
                                        |                                              |
                                        | 4                                            |
                                        v                                              |
                                 next_rendezvous                                       |
                                        +                                              |
                                        |                                              |
                                        v                                              |
            +---------------------------+---------------+                              |
            | _op_executor.run(_RendezvousJoinOp)       |                              |
            |           +               +               |                              |
            |           |               |               |                              |
            |           |               | 5             |                              |
            |           |               v               |                              |
            |           |       ADD_TO_PARTICIPANTS     |                              |
            |           |               +               |   +-----------------------+  |
            |           |               |               |   | _RendezvousState      |  |
            |           | &lt;-------------+               |   |                       |  |
            |           |                               |   | participants = [1,2,3]|  |
            |           v     6                  7      |   |                       |  |
            |        _add_to_participants  +--------------&gt; | wait_list = []        |  |
            |                                           |   |                       |  |
            +-------------------------------------------+   +-----------------------+  v

                                                                                 Timeline


</code></pre>
<h2 id="0x03-节点离开">0x03 节点离开</h2>
<h3 id="31-处理机制">3.1 处理机制</h3>
<p>节点离开（scale-down）的处理如下：</p>
<ul>
<li>当Scale down事件发生时，rendezvous将不会通知 torchelastic agent。</li>
<li>如果TE agent以“max_restarts=0”启动，它依赖于底层调度程序来处理作业重新启动。</li>
<li>如果“max_restarts&gt;0”，TE代理将终止workers并开始新一轮rendezvous。
<ul>
<li>代理得到离开的通知，于是现有workers（所有节点上）都全部停止。</li>
<li>这些workers将形成一个新的“WorkerGroup”，所有worker都将以新的<code>RANK</code> 和  <code>WORLD_SIZE</code> 运行。、</li>
</ul>
</li>
</ul>
<h3 id="32-如何模拟">3.2 如何模拟</h3>
<p>如果想模拟调试的同学，可以在 test/distributed/elastic/agent/server/test/local_elastic_agent_test.py 之中找到示例代码。</p>
<pre><code class="language-python">def test_double_agent_elastic(self):
    """
    start ``nnodes`` agents, kill odd ones (do not restart), validate
    elasticity (scale-down) works. (scale-up covered in fault_tolerance test)
    """
    min_nodes = 1
    max_nodes = 2
    wait = 2
    node_conf = Conf(entrypoint=_dist_sum, args=(wait,), local_world_size=2)
    agent_results = mp.Queue()
    agent_args = {
        "conf": node_conf,
        "agent_results": agent_results,
        "min_nodes": min_nodes,
        "max_nodes": max_nodes,
        "max_restarts": 2,
    }

    procs = []
    for _ in range(max_nodes):
        p = mp.Process(
            target=self.run_agent,
            kwargs=agent_args,
        )
        procs.append(p)
        p.start()

    # kill odd agents
    for i in range(max_nodes):
        if i % 2 != 0:
            procs[i].kill()

    for i in range(max_nodes):
        p = procs[i]
        p.join()
        if i % 2 == 0:
            self.assertEqual(0, p.exitcode)
        else:
            self.assertEqual(-signal.SIGKILL, p.exitcode)
</code></pre>
<h3 id="33-如何处理">3.3 如何处理</h3>
<p>节点离开，与错误处理是同一个代码。错误处理代码如下，如果重试尚未达到最大次数，则试图重启workers。如果已经达到了最大次数，则停止 workers。</p>
<pre><code class="language-python">    def _invoke_run(self, role: str = DEFAULT_ROLE) -&gt; RunResult:
        
        # 省略
     
        while True:

            # 定期监控
            time.sleep(monitor_interval)
            # 监控客户程序运行情况
            run_result = self._monitor_workers(self._worker_group)
            
            elif state in {WorkerState.UNHEALTHY, WorkerState.FAILED}:
            # 程序出错
            
            if self._remaining_restarts &gt; 0: # 重试
                self._remaining_restarts -= 1
                self._restart_workers(self._worker_group) # 进行重启
            else:
                self._stop_workers(self._worker_group) # 重试次数达到，结束workers
                self._worker_group.state = WorkerState.FAILED
                self._exit_barrier()
                return run_result
</code></pre>
<h4 id="331-重启">3.3.1 重启</h4>
<p>_restart_workers 会停掉所有 workers，然后重新一轮 rendezvous 。</p>
<pre><code class="language-python">@prof
def _restart_workers(self, worker_group: WorkerGroup) -&gt; None:
    """
    Restarts (stops, rendezvous, starts) all local workers in the group.
    """

    role = worker_group.spec.role
    self._stop_workers(worker_group)
    worker_group.state = WorkerState.STOPPED
    self._initialize_workers(worker_group)
</code></pre>
<h4 id="332-停止">3.3.2 停止</h4>
<p>停止 workers 就是关闭上下文。</p>
<pre><code class="language-python">def _shutdown(self) -&gt; None:
    if self._pcontext:
        self._pcontext.close()
        
@prof
def _stop_workers(self, worker_group: WorkerGroup) -&gt; None:
    self._shutdown()
</code></pre>
<p>在 MultiprocessContext 之中，close 方法是关闭所有子进程，然后等待其全部停止。</p>
<pre><code class="language-python">    def _close(self) -&gt; None:
        if self._pc:
            for proc in self._pc.processes:
                proc.terminate()
                proc.join()
</code></pre>
<p>流程图如下：</p>
<ol>
<li>监控子进程状态。</li>
<li>发现 UNHEALTHY 或者 FAILED，看看重启次数是否还有。我们假定是3号进程失败。</li>
<li>如果没有，就调用 _stop_workers 结束子进程。</li>
<li>调用 MultiprocessContext.close 进行具体结束操作。</li>
<li>如果还可以重启，调用_restart_workers。</li>
<li>调用 _stop_workers 结束子进程。</li>
<li>调用 MultiprocessContext.close 进行具体结束操作。</li>
<li>调用 _initialize_workers 重新初始化worker。</li>
<li>调用 next_rendezvous 重新同步。</li>
<li>进行后续操作。</li>
</ol>
<pre><code class="language-python">                                                                                 +
+-------------------------------------------+    +---------------------------+   |
| agent._invoke_run                         |    | _RendezvousState          |   |
|                                           |    |                           |   |
|                                           |    |                           |   |
|     _monitor_workers Every 30S            |    |    participants = [1,2,3] |   |
|             +                             |    |                           |   |
|             | 1                           |    |    wait_list = [ ]        |   |
|             |                             |    |                           |   |
|             v                             |    +---------------------------+   |
|     WorkerState.UNHEALTHY,FAILED          |                                    |
|             +                             |                                    |
|             |                             |                                    |
|             | 2                           |                                    |
|             v                             |                                    |
|   self._remaining_restarts &gt; 0 ? +--+     |                                    |
|             +                       |     |                                    |
|          5  | YES                NO | 3   |                                    |
|             |                       |     |                                    |
|             v                       v     |    +----------------------+        |
|     _restart_workers        _stop_workers |    | MultiprocessContext  |        |
|             +                       +     |    |                      |        |
|             | 6                     |  4  |    |                      |        |
|             |                       +--------&gt; |                      |        |
|             v                             |    |        close()       |        |
|      _stop_workers +-------------------------&gt; |                      |        |
|             +                 7           |    +----------------------+        |
|             |                             |                                    |
|             | 8                           |                                    |
|             v                             |                                    |
|    _initialize_workers                    |                                    |
|             +                             |                                    |
|             |                             |                                    |
+-------------------------------------------+                                    |
              | 9                                                                |
              |                                                                  |
              v                                +--------------------------+      |
        next_rendezvous                        | _RendezvousState         |      |
              +                                |                          |      |
              |               10               |     participants = [1,2] |      |
              +----------------------------&gt;   |                          |      |
              |                                |     wait_list = [ ]      |      v
              | 10                             +--------------------------+
              v                                                             Timeline
</code></pre>
<p>至此，弹性训练全部分析完毕，或者说PyTorch分布式分析就告一段落，我们下文会介绍其他框架/库的分布式实现，敬请期待。</p>
<h2 id="0xff-参考">0xFF 参考</h2>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15718043.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(1) --- 总体思路</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15725911.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(2)---启动&amp;单节点流程</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15728861.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(3)---代理</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15735170.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(4)---Rendezvous 架构和逻辑</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15739391.html" target="_blank">源码解析] PyTorch 分布式之弹性训练(5)---Rendezvous 引擎</a></p>

</div>
<div class="clear"></div>
<div id="blog_post_info_block" role="contentinfo">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1225.099405921309" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2021-12-31 14:31">2021-12-31 14:31</span>&nbsp;
<a href="https://www.cnblogs.com/rossiXYZ">罗西的思考</a>&nbsp;
阅读(<span id="post_view_count">941</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(15743246);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '15743246', targetLink: 'https://www.cnblogs.com/rossiXYZ/p/15743246.html', title: '[源码解析] PyTorch 分布式之弹性训练(7)---节点变化' })">举报</a>
</div>
        </div>
        <script>
    var cb_entryId = 15743246, cb_entryCreatedDate = '2021-12-31 14:31', cb_postType = 1, cb_postTitle = '[源码解析] PyTorch 分布式之弹性训练(7)---节点变化';
    var allowComments = true, cb_blogId = 556264, cb_blogApp = 'rossiXYZ', cb_blogUserGuid = '3d1961d5-3b13-4975-9d25-08d753a9a8fd';
    mermaidRender.render()
    markdown_highlight()
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");    
</script>
        <a id="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"> 
        <div class="comment-nav-right">
            <span id="span_refresh_tips"></span><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a>
        </div>
    </div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
        <div id="cnblogs_ch"></div>
    <div id="opt_under_post"></div>
        <div id="blog_c1" class="under-post-card">
            <a href="https://www.doubao.com?channel=cnblogs&amp;source=hw_db_cnblogs&amp;type=lunt&amp;theme=bianc" rel="nofollow" target="_blank" onclick="countCreativeClicks('C1-字节-豆包')">
                <img src="https://img2024.cnblogs.com/blog/35695/202412/35695-20241201072501456-2052907165.jpg" onload="countCreativeImpressions('C1-字节-豆包')" alt="" />
                <span id="c1_impression" style="display:none"></span>
            </a>
        </div>
    <div id="under_post_card1"></div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
        var commentManager = new blogCommentManager();
        commentManager.renderComments(0);
        fixPostBody();
        window.footnoteTipManager.generateFootnoteTips();

            window.tocManager.displayDisableTocTips = false;
            window.tocManager.generateToc();
            
                setTimeout(function() { countViews(cb_blogId, cb_entryId); }, 50);
            
            deliverT2();
            deliverC1C2();
            loadNewsAndKb();
            
                LoadPostCategoriesTags(cb_blogId, cb_entryId);
            
            LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
            GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
            loadOptUnderPost();
            GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
                </script>
</div>

    </div>
</div>
            </div>
        </div>

        <div id="sideBar">
            <div id="sideBarMain">
                <div id="sidebar_news" class="newsItem">
    
<h3 class="catListTitle">公告</h3>
<div id="blog-news" class="sidebar-news">
    <div id="sidebar_news_container">
    </div>
</div>
<script>loadBlogNews();</script> 
</div>
<div id="sidebar_c3"></div>
                <div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                <script>loadBlogDefaultCalendar();</script>
                <div id="leftcontentcontainer">
                    <!-- begin:SingleColumn -->
                    <div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
                    <!-- end:  SingleColumn -->
                </div>
            </div>
        </div>
        <div class="clear"></div>
    </div>
    <div class="clear"></div>
    <div id="footer">
        <!--done-->
Copyright &copy; 2025 罗西的思考
<br /><span id="poweredby">Powered by .NET 9.0 on Kubernetes</span>

    </div>
</div>


    

    <input type="hidden" id="antiforgery_token" value="CfDJ8Ct_7-Gh-gZNte6RB_khjDqEVgoKUmuDLyF24p1rmWuPDa_Zjdn5ry4U_8SzCaDW1nO2-0PHdR_eqXda5NGIc4oVU9lZNZ96LdcxCq6vz6c92zqqPo21eHRCfXjoqMy9Xt4JJYgF8M5HxugqK73ObjM" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M95P3TTWJZ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-M95P3TTWJZ');
</script>
<script defer src="https://hm.baidu.com/hm.js?866c9be12d4a814454792b1fd0fed295"></script>
</body>
</html>
