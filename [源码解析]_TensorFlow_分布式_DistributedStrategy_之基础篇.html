<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-cross-origin" />
    <meta name="keywords" content="001_机器学习,006_深度学习,011_分布式机器学习" />
    <meta name="description" content="我们接下来介绍TensorFlow分布式Strategy的基础，本文会先看看Strategy的类体系和如何处理数据，下一篇看看如何处理变量。" />
    <meta property="og:description" content="我们接下来介绍TensorFlow分布式Strategy的基础，本文会先看看Strategy的类体系和如何处理数据，下一篇看看如何处理变量。" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇 - 罗西的思考 - 博客园</title>
    <link rel="icon" id="favicon" href="https://assets.cnblogs.com/favicon_v3_2.ico" type="image/x-icon" />
    <link rel="canonical" href="https://www.cnblogs.com/rossiXYZ/p/16133750.html" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=3DArmf-Or-4qxFZkl3OdynS2Am4I6_pcIbQbRZRdGaM" />
    

    <link id="MainCss" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright.min.css?v=O5zHESxCF0tzyVg01nX06fLeohvC5JYxsLWE4NmQOMg" />
        <link id="highlighter-theme-cnblogs" type="text/css" rel="stylesheet" href="/css/hljs/cnblogs.css?v=5J1NDtbnnIr2Rc2SdhEMlMxD4l9Eydj88B31E7_NhS4" />
    
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/lessismoreright/bundle-lessismoreright-mobile.min.css?v=Uw1Hg7i9RFPazLAd0cWltL-cniUkUgHHPLh7ZV9ZL9o" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/rossiXYZ/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/rossiXYZ/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/rossiXYZ/wlwmanifest.xml" />
    
    <script type="application/ld&#x2B;json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "@id": "https://www.cnblogs.com/rossiXYZ/p/16133750.html",
      "headline": "[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇",
      "description": "[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇 前文之中我们已经介绍了 Strategy 这个基本概念，tf.distribute.Strategy 是一个可在多个 GPU、多台机器或 TPU 上进行分布式训练的 TensorFlow API。使用此 A",
      "image": [
        
      ],
      "author": {
        "@type": "Person",
        "@id": "https://www.cnblogs.com/rossiXYZ/",
        "name": "罗西的思考",
        "url": "https://www.cnblogs.com/rossiXYZ/"
      },
      "publisher": {
        "@type": "Organization",
        "@id": "https://www.cnblogs.com/",
        "name": "博客园",
        "url": "https://www.cnblogs.com/"
      },
      "datePublished": "2022-04-12T14:21:00.0000000&#x2B;08:00",
      "dateModified": "2022-04-12T14:21:00.0000000&#x2B;08:00",
      "wordCount": "76997",
      "isPartOf": {
        "@type": "Blog",
        "@id": "https://www.cnblogs.com/rossiXYZ/",
        "name": "罗西的思考",
        "publisher": {
          "@type": "Organization",
          "@id": "https://www.cnblogs.com/",
          "name": "博客园"
        }
      }
    }
    </script>

    <script>
        var currentBlogId = 556264;
        var currentBlogApp = 'rossiXYZ';
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'LessIsMoreRight';
        var visitorUserId = '';
        var hasCustomScript = false;
        window.cb_enable_mathjax = true;
        window.mathEngine = 0;
        window.codeHighlightEngine = 1;
        window.enableCodeLineNumber = false;
        window.codeHighlightTheme = 'cnblogs';
        window.darkModeCodeHighlightTheme = 'vs2015';
        window.isDarkCodeHighlightTheme = false;
        window.isDarkModeCodeHighlightThemeDark = true;
        window.isDisableCodeHighlighter = false;
        window.enableCodeThemeTypeFollowSystem = false;
        window.enableMacStyleCodeBlock = false;
    </script>
        <script>
            window.currentPostId = 16133750;
            window.currentPostDateAdded = '2022-04-12 14:21';
        </script>
    <script src="https://assets.cnblogs.com/scripts/jquery-3.3.1.min.js"></script>
    <script src="https://cdn-www.cnblogs.com/js/blog-common.min.js?v=wZ-j9lgqsnaTqSE7AdWd3J3j9ENiZHPW0sel6vKY_Mo"></script>
    
</head>
<body class="skin-lessismoreright has-navbar mathjax2">
    <a name="top"></a>
        <div id="imagebar" class="imagebar-mobile imagebar-text-mobile formobile">
                <a href="https://www.doubao.com?channel=cnblogs&amp;source=hw_db_cnblogs&amp;type=lunt&amp;theme=bianc" onclick="countCreativeClicks('M2-字节-豆包')" rel="nofollow">
                    <img src="https://img2024.cnblogs.com/blog/35695/202412/35695-20241201073014811-1847930772.jpg" alt="" onload="countCreativeImpressionsOnMobile('M2-字节-豆包')" />
                    <span id="m2_impression" style="display:none"></span>
                </a>
        </div>
    <div id="top_nav" class="navbar forpc">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding">                    
                    <a href="https://www.cnblogs.com/" title="开发者的网上家园" role="banner">
                        <img src="//assets.cnblogs.com/logo.svg" alt="博客园logo" />
                    </a>
                </li>               
                <li><a href="https://cnblogs.vip/">会员</a></li>
                <li><a href="https://cnblogs.vip/store">周边</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-q')">博问</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="countClicks('nav', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://www.cnblogs.com/cmt/p/18341478">赞助商</a></li>
                <li><a href="https://chat2db-ai.com/" target="_blank" onclick="countClicks('nav', 'skin-navbar-chat2db')">Chat2DB</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search dropdown" action="https://zzk.cnblogs.com/s" method="get" role="search">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="search" tabindex="3" autocomplete="off" />
                        <button id="zzk_search_button" onclick="window.navbarSearchManager.triggerActiveOption()">
                            <img id="search_icon" class="focus-hidden" src="//assets.cnblogs.com/icons/search.svg" alt="搜索" />
                            <img class="hidden focus-visible" src="//assets.cnblogs.com/icons/enter.svg" alt="搜索" />
                        </button>
                        <ul id="navbar_search_options" class="dropdown-menu quick-search-menu">
                            <li tabindex="0" class="active" onclick="zzkSearch(event, document.getElementById('zzk_search_input').value)">
                                <div class="keyword-wrapper">
                                    <img src="//assets.cnblogs.com/icons/search.svg" alt="搜索" />
                                    <div class="keyword"></div>
                                </div>
                                <span class="search-area">所有博客</span>
                            </li>
                                    <li tabindex="1" onclick="zzkBlogSearch(event, 'rossiXYZ', document.getElementById('zzk_search_input').value)">
                                        <div class="keyword-wrapper">
                                            <img src="//assets.cnblogs.com/icons/search.svg" alt="搜索" />
                                            <div class="keyword"></div>
                                        </div>
                                        <span class="search-area">当前博客</span>
                                    </li>
                        </ul>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="//assets.cnblogs.com/icons/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="//assets.cnblogs.com/icons/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="//assets.cnblogs.com/icons/message.svg" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <a id="navbar_lite_mode_indicator" data-current-page="blog" style="display: none" href="javascript:void(0)" alt="简洁模式" title="简洁模式启用，您在访问他人博客时会使用简洁款皮肤展示">
                        <img class="navbar-icon" src="//assets.cnblogs.com/icons/lite-mode-on.svg" alt="简洁模式" />
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="//assets.cnblogs.com/icons/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="https://vip.cnblogs.com/my">会员中心</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>

                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    <div id="page_begin_html">
        

    </div>

    <div id="home">
    <div id="header">
        <div id="blogTitle">
            <div class="title"><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/rossiXYZ">罗西的思考</a>
</div>
<div class="subtitle">一手伸向技术，一手伸向生活</div>

        </div>
        <div id="navigator">
            
<ul id="navList">
    <li id="nav_sitehome"><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
    <li id="nav_myhome">
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/rossiXYZ/">
首页</a>
</li>
    <li id="nav_newpost">

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
    <li id="nav_contact">
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%BD%97%E8%A5%BF%E7%9A%84%E6%80%9D%E8%80%83">
联系</a></li>
    <li id="nav_rss">
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/rossiXYZ/rss/">
订阅</a></li>
    <li id="nav_admin">
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>

            <div class="blogStats">
                <div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
            </div>
        </div>
    </div>
    <div id="main">
        <div id="mainContent">
            <div class="forFlow">
                <div id="post_detail">
    <div id="topics">
        <div class="post">
            <h1 class="postTitle">
                <a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/rossiXYZ/p/16133750.html" title="发布于 2022-04-12 14:21">
    <span role="heading" aria-level="2">[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇</span>
    

</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                    <div id="cnblogs_post_description" style="display: none">
        
        我们接下来介绍TensorFlow分布式Strategy的基础，本文会先看看Strategy的类体系和如何处理数据，下一篇看看如何处理变量。
    </div>
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="源码解析-tensorflow-分布式-distributedstrategy-之基础篇">[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇</h1>
<p></p><div class="toc"><div class="toc-container-header">目录</div><ul><li><a href="#源码解析-tensorflow-分布式-distributedstrategy-之基础篇" rel="noopener nofollow">[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇</a><ul><li><a href="#1-strategybase" rel="noopener nofollow">1. StrategyBase</a><ul><li><a href="#11-初始化" rel="noopener nofollow">1.1 初始化</a></li><li><a href="#12-使用" rel="noopener nofollow">1.2 使用</a></li><li><a href="#13-ctl" rel="noopener nofollow">1.3 CTL</a></li><li><a href="#14-scope" rel="noopener nofollow">1.4 Scope</a><ul><li><a href="#141-使用" rel="noopener nofollow">1.4.1 使用</a></li><li><a href="#142-功能" rel="noopener nofollow">1.4.2 功能</a></li><li><a href="#143-scope-范围" rel="noopener nofollow">1.4.3 Scope 范围</a></li></ul></li><li><a href="#15-strategyextendedv2" rel="noopener nofollow">1.5 StrategyExtendedV2</a><ul><li><a href="#151-locality" rel="noopener nofollow">1.5.1 locality</a></li><li><a href="#152-如何更新" rel="noopener nofollow">1.5.2 如何更新</a></li></ul></li><li><a href="#16-继承关系" rel="noopener nofollow">1.6 继承关系</a></li></ul></li><li><a href="#2-读取数据" rel="noopener nofollow">2. 读取数据</a><ul><li><a href="#21-直接读取数据集" rel="noopener nofollow">2.1 直接读取数据集</a><ul><li><a href="#211-用例" rel="noopener nofollow">2.1.1 用例</a></li><li><a href="#212-基类实现" rel="noopener nofollow">2.1.2 基类实现</a></li><li><a href="#213-mirroredextended-实现" rel="noopener nofollow">2.1.3 MirroredExtended 实现</a></li><li><a href="#214-input_lib-功能" rel="noopener nofollow">2.1.4 input_lib 功能</a></li><li><a href="#215-inputworkers" rel="noopener nofollow">2.1.5 InputWorkers</a><ul><li><a href="#定义" rel="noopener nofollow">定义</a></li><li><a href="#构建" rel="noopener nofollow">构建</a></li></ul></li><li><a href="#216-distributeddataset" rel="noopener nofollow">2.1.6 DistributedDataset</a><ul><li><a href="#初始化" rel="noopener nofollow">初始化</a></li><li><a href="#建立数据" rel="noopener nofollow">建立数据</a></li><li><a href="#数据集" rel="noopener nofollow">数据集</a></li><li><a href="#迭代数据" rel="noopener nofollow">迭代数据</a></li></ul></li><li><a href="#217-distributediterator" rel="noopener nofollow">2.1.7 DistributedIterator</a><ul><li><a href="#distributediterator" rel="noopener nofollow">DistributedIterator</a></li><li><a href="#distributediteratorbase" rel="noopener nofollow">DistributedIteratorBase</a></li></ul></li></ul></li><li><a href="#22-通过方法初始化" rel="noopener nofollow">2.2 通过方法初始化</a><ul><li><a href="#221-strategybase" rel="noopener nofollow">2.2.1 StrategyBase</a></li><li><a href="#222-mirroredstrategy" rel="noopener nofollow">2.2.2 MirroredStrategy</a></li><li><a href="#223-建立-inputworkers" rel="noopener nofollow">2.2.3 建立 InputWorkers</a></li><li><a href="#224-input_contexts" rel="noopener nofollow">2.2.4 input_contexts</a></li><li><a href="#225--返回数据集" rel="noopener nofollow">2.2.5  返回数据集</a></li><li><a href="#226-构建数据集" rel="noopener nofollow">2.2.6 构建数据集</a></li></ul></li><li><a href="#23-高层使用" rel="noopener nofollow">2.3 高层使用</a><ul><li><a href="#231-keras" rel="noopener nofollow">2.3.1 Keras</a></li><li><a href="#222-其他路径" rel="noopener nofollow">2.2.2 其他路径</a></li></ul></li></ul></li><li><a href="#0xff-参考" rel="noopener nofollow">0xFF 参考</a></li></ul></li></ul></div><p></p>
<p>前文之中我们已经介绍了 Strategy 这个基本概念，tf.distribute.Strategy 是一个可在多个 GPU、多台机器或 TPU 上进行分布式训练的 TensorFlow API。使用此 API，您只需改动较少代码就能基于现有模型和训练代码来实现单机多卡，多机多卡等情况的分布式训练。tf.distribute.Strategy 旨在实现以下目标：</p>
<ul>
<li>覆盖不同维度的用户用例。</li>
<li>易于使用，支持多种用户（包括研究人员和 ML 工程师等）。</li>
<li>提供开箱即用的高性能。</li>
<li>从用户模型代码之中解耦，这样可以轻松切换策略。</li>
<li>支持 Custom Training Loop，Estimator，Keras。</li>
<li>支持 eager excution。</li>
</ul>
<p>从系统角度或者说从开发者的角度看，Strategy 是基于Python作用域或装饰器来实现的一套机制。它提供了一组命名的分布式策略，如ParameterServerStrategy、CollectiveStrategy来作为Python作用域，这些策略可以被用来捕获用户函数中的模型声明和训练逻辑，其将在用户代码开始时生效。在后端，分布式系统可以重写计算图，并根据选择的策略（参数服务器或集合）合并相应的语义。</p>
<p>因此<strong>我们分析的核心就是如何把数据读取，模型参数，分布式计算融合到Python作用域或装饰器之中</strong>，本章我们就从 Strategy 的类体系结构和读取数据开始。</p>
<p>依然安利两个大神：</p>
<p>[TensorFlow Internals] (<a href="https://github.com/horance-liu/tensorflow-internals" target="_blank" rel="noopener nofollow">https://github.com/horance-liu/tensorflow-internals</a>)，虽然其分析的不是最新代码，但是建议对 TF 内部实现机制有兴趣的朋友都去阅读一下，绝对大有收获。<br>
<a href="https://home.cnblogs.com/u/deep-learning-stacks/" target="_blank">https://home.cnblogs.com/u/deep-learning-stacks/</a> 西门宇少，不仅仅是 TensorFlow，其公共号还有更多其他领域，业界前沿。</p>
<p>本系列其他文章是：</p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/15996273.html" target="_blank">翻译] TensorFlow 分布式之论文篇 "TensorFlow : Large-Scale Machine Learning on Heterogeneous Distributed Systems"</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16009379.html" target="_blank">翻译] TensorFlow 分布式之论文篇 "Implementation of Control Flow in TensorFlow"</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16014121.html" target="_blank">源码解析] TensorFlow 分布式环境(1) --- 总体架构</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16024266.html" target="_blank">源码解析] TensorFlow 分布式环境(2)---Master 静态逻辑</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16036093.html" target="_blank">源码解析] TensorFlow 分布式环境(3)--- Worker 静态逻辑</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16046365.html" target="_blank">源码解析] TensorFlow 分布式环境(4) --- WorkerCache</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16065124.html" target="_blank">源码解析] TensorFlow 分布式环境(5) --- Session</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16069420.html" target="_blank">源码解析] TensorFlow 分布式环境(7) --- Worker 动态逻辑</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16103816.html" target="_blank">源码解析] TensorFlow 分布式环境(8) --- 通信机制</a></p>
<p>[<a href="https://www.cnblogs.com/rossiXYZ/p/16123267.html" target="_blank">翻译] 使用 TensorFlow 进行分布式训练</a></p>
<h2 id="1-strategybase">1. StrategyBase</h2>
<p>StrategyBase 是一个设备列表之上的状态和计算分布策略。是 v1 策略和 v2 策略类的基类。</p>
<h3 id="11-初始化">1.1 初始化</h3>
<p>StrategyBase 初始化方法之中最主要就是设定 extended，其类型是 StrategyExtendedV2 或者 StrategyExtendedV1。</p>
<pre><code class="language-python">class StrategyBase(object):

  def __init__(self, extended):
    
    self._extended = extended

    # Flag that is used to indicate whether distribution strategy is used with
    # Estimator. This is required for backward compatibility of loss scaling
    # when using v1 optimizer with estimator.
    self._scale_loss_for_estimator = False

    if not hasattr(extended, _retrace_functions_for_each_device):
        # extended._retrace_functions_for_each_device dictates
      # whether the same function will be retraced when it is called on
      # different devices.
      try:
        extended._retrace_functions_for_each_device = (
            len(extended.worker_devices) &gt; 1)
        distribution_strategy_replica_gauge.get_cell(num_replicas).set(
            self.num_replicas_in_sync)
      except:  
        # Default for the case where extended.worker_devices can't return
        # a sensible value.
        extended._retrace_functions_for_each_device = True

    # Below are the dicts of axis(int) -&gt; tf.function.
    self._mean_reduce_helper_fns = {}
    self._reduce_sum_fns = {}

    # Whether this strategy is designed to work with ClusterCoordinator.
    self._should_use_with_coordinator = False

  @property
  def extended(self):
    ```tf.distribute.StrategyExtended with additional methods.```
    return self._extended
</code></pre>
<h3 id="12-使用">1.2 使用</h3>
<p>如果想使用 Keras compile/fit，请参照 <a href="https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_keras%E3%80%82" target="_blank" rel="noopener nofollow">https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_keras。</a></p>
<p>也可以将 tf.distribution.Strategy 的派生类传递给 tf.estimator.RunConfig 来指定 tf.estimator.Estimator 应该如何分配计算，具体可以参照 <a href="https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_estimator_limited_support%E3%80%82" target="_blank" rel="noopener nofollow">https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_estimator_limited_support。</a></p>
<p>在建立和执行模型时，应该首先使用 tf.distribution.Strategy.scope 来指定一个策略。 指定策略意味着这将使代码处于这个策略的 cross-replica context 中，因此这个策略将负责控制比如 variable placement 这样的功能。</p>
<h3 id="13-ctl">1.3 CTL</h3>
<p>如果您正在编写一个自定义的训练循环（custom training loop），您将需要多调用一些方法，</p>
<ul>
<li>使用 tf.distribut.Strategy.experimental_distribute_dataset 将 tf.data.Dataset 转换，使之能产生 per-replica 值。如果您想手动指定数据集如何在各个副本之间进行划分，请使用tf.distribut.Strategy.distribut_datasets_from_function。</li>
<li>使用 tf.distribution.Strategy.run 为每个副本运行函数，该函数使用 per-replica 的值（例如来自tf.distribution.DistributedDataset对象）并返回一个 per-replica。这个函数是在 <u>副本上下文</u> 中执行的，这意味着每个操作都在每个副本上单独执行。</li>
<li>最后使用一个方法（如tf.distributed.Strategy.reduce）将得到的 per-replica 的值转换成普通的张量。</li>
</ul>
<p>下面代码是 CTL 一个典型用例，其使用一个普通的 dataset 和 replica_fn 在名为 my_strategy 的特定 tf.distribution.Strategy 下分布式运行。在 replica_fn 中创建的任何变量都是使用 my_strategy 的策略创建的。</p>
<p>用户可以使用 reduce API 来聚合各副本的结果，并将其作为对 tf.distributedDataset 进行一次迭代的返回值。用户也可以使用 tf.keras.metrics（如损失、准确度等）来累积各步骤的度量。</p>
<pre><code class="language-python">  with my_strategy.scope():
    @tf.function
    def distribute_train_epoch(dataset):
      def replica_fn(input):
        # process input and return result
        return result

      total_result = 0
      for x in dataset:
        per_replica_result = my_strategy.run(replica_fn, args=(x,))
        total_result += my_strategy.reduce(tf.distribute.ReduceOp.SUM,
                                           per_replica_result, axis=None)
      return total_result

    dist_dataset = my_strategy.experimental_distribute_dataset(dataset)
    for _ in range(EPOCHS):
      train_result = distribute_train_epoch(dist_dataset)
</code></pre>
<h3 id="14-scope">1.4 Scope</h3>
<p>分发策略的范围（作用域）决定了如何创建变量以及在何处创建变量，比如对于 MultiWorkerMirroredStrategy 而言，创建的变量类型是 MirroredVariable ，策略将它们复制到每个工作者之上。Scope 的方法主要是通过调用 _extended._scope 来完成。该方法返回了一个 Context manager，这可以设置本策略为当前策略，并且分发变量。</p>
<pre><code class="language-python">def scope(self):
    
    """Context manager to make the strategy current and distribute variables.
   
    Returns:
    A context manager.
   """
  return self._extended._scope(self)  
</code></pre>
<h4 id="141-使用">1.4.1 使用</h4>
<p>具体使用方法如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; strategy = tf.distribute.MirroredStrategy([GPU:0, GPU:1])
&gt;&gt;&gt; # Variable created inside scope:
&gt;&gt;&gt; with strategy.scope():
...   mirrored_variable = tf.Variable(1.)
&gt;&gt;&gt; mirrored_variable
MirroredVariable:{
  0: &lt;tf.Variable 'Variable:0' shape=() dtype=float32, numpy=1.0&gt;,
  1: &lt;tf.Variable 'Variable/replica_1:0' shape=() dtype=float32, numpy=1.0&gt;
}
&gt;&gt;&gt; # Variable created outside scope:
&gt;&gt;&gt; regular_variable = tf.Variable(1.)
&gt;&gt;&gt; regular_variable
&lt;tf.Variable 'Variable:0' shape=() dtype=float32, numpy=1.0&gt;
</code></pre>
<h4 id="142-功能">1.4.2 功能</h4>
<p>当进入了 Strategy.scope 之后，会执行如下操作:</p>
<ul>
<li>strategy 被安装在全局上下文内，作为当前策略。 在这个范围内，调用 tf.distribution.get_strategy() 将返回这个策略。在这个范围之外，它将返回默认的无操作（no-op）策略。</li>
<li>进入这个 scope 也就进入了 cross-replica context。</li>
<li>scope 内的变量创建将被策略拦截。每个策略都定义了它要如何影响变量的创建。像 MirroredStrategy、TPUStrategy 和 MultiWorkerMiroredStrategy 这样的同步策略在每个副本上创建变量，而ParameterServerStrategy 在参数服务器上创建变量。这是在策略自定义的 tf.variable_creator_scope 之中完成的。</li>
<li>在某些策略中也可以输入默认的设备范围：在 MultiWorkerMiroredStrategy 中，每个 worker 上输入的默认设备范围是 /CPU:0。</li>
</ul>
<p>注意：进入 Scope 不会自动分配计算，除非是像 keras model.fit 这样的高层训练框架。如果您没有使用 model.fit，您需要使用 strategy.run API 来明确分配该计算。</p>
<h4 id="143-scope-范围">1.4.3 Scope 范围</h4>
<p>什么在 Scope 之内？什么在之外？</p>
<ul>
<li>任何创建分布式变量的操作都必须在 strategy.scope 中调用。这可以通过在范围上下文中直接调用变量创建函数来实现，或者由 strategy.run 或 Keras.Model.fit 自动为您输入。</li>
<li>任何可能惰性创建变量的函数（例如，Model.<strong>call</strong>()，追踪一个tf.function，等等）也应该在作用域内调用。</li>
<li>变量创建的另一个来源可以是检查点的恢复。</li>
<li>任何在作用域之外创建的变量都不会被分发。</li>
</ul>
<p>请注意，任何在策略内部创建的变量都会捕获策略信息。因此，在 strategy.scope 之外对这些变量的读写也可以无缝进行，而不需要用户进入 scope。</p>
<p>一些需要进入策略范围的策略 API（如strategy.run和strategy.reduce）会自动进入 scope，这意味着在使用这些API 时，您不需要自己明确进入 scope。</p>
<p>模型、优化器、Metrics 可以在 TF 之中创建变量，这样的对象应该总是在作用域内初始化。当 tf.keras.Model 在strategy.scope 内被创建，Model 对象会捕获范围信息。当高层的训练框架方法，如 model.compile，model.fit 等被调用时，捕获的范围将被自动输入，相关的策略将被用来分配训练等。</p>
<p>警告：简单地调用model(..)不会自动进入 Strategy 的范围 -- 只有高水平的训练框架 API 支持这种行为：model.compile、model.fit、model.evaluation、model.predict 和 model.save 都可以在范围内或范围外调用。</p>
<h3 id="15-strategyextendedv2">1.5 StrategyExtendedV2</h3>
<p>StrategyExtendedV2 为需要分布感知（distribution-aware）的算法提供额外的API。</p>
<pre><code class="language-python">@tf_export(distribute.StrategyExtended, v1=[])
class StrategyExtendedV2(object):
    # Additional APIs for algorithms that need to be distribution-aware.
</code></pre>
<h4 id="151-locality">1.5.1 locality</h4>
<p>tf.distributed.DistributedValues 可以具有与分布式变量相同的 <em>locality</em>，这导致 mirrored value 会驻留在与变量相同的设备上（而不是计算设备上）。针对 <em>locality</em>，用户可以做如下操作：</p>
<ul>
<li>可以使用 tf.distribution.StrategyExtended.update 来更新变量的值。</li>
<li>可以使用 tf.distribution.StrategyExtended.colocate_vars_with 来让一个变量与另一个变量有相同的 locality。</li>
<li>可以使用 tf.distribution.StrategyExtended.reduce_to 或 tf.distribution.StrategyExtended.batch_reduce_to 将 PerReplica  value 转换到另一个变量的 locality。</li>
</ul>
<h4 id="152-如何更新">1.5.2 如何更新</h4>
<p>接下来我们看看如何更新一个分布式变量（distributed variable）。分布式变量（distributed variable）是在多个设备上创建的变量，比如镜像变量和同步读取（SyncOnRead）变量。更新分布式变量的标准模式是：</p>
<ol>
<li>在传递给 tf.distribution.Strategy.run 的函数中来计算得到一个（update, variable）对列表。例如，更新可能是一个变量的损失梯度。</li>
<li>通过调用 tf.distribution.get_replica_context().merge_call() 来切换到 cross-replica 模式，调用时将更新和变量作为参数。</li>
<li>通过调用 tf.distribution.StrategyExtended.reduce_to(VariableAggregation.SUM, t, v)（针对一个变量）或tf.distribution.StrategyExtended.batch_reduce_to（针对一个变量列表）来对更新进行求和。</li>
<li>可以为每个变量调用 tf.distribution.StrategyExtended.update(v) 来更新它的值。</li>
</ol>
<p>如果您在副本上下文中调用 tf.keras.optimizer.Optimizer.apply_gradients方法，则步骤 2 到 4 会由类tf.keras.optimizer.Optimizer 自动完成。</p>
<p>事实上，更新分布式变量的更高层次的解决方案是对该变量调用 assign，就像您对普通的 tf.Variable 一样操作。您可以在 <em>replica context</em> 和 <em>cross-replica context</em> 中调用该方法。</p>
<p>对于一个 <em>mirrored 变量</em>，在 <em>replica context</em> 中调用 assign 需要在变量构造函数中指定aggregation类型。在这种情况下，您需要自行处理在步骤2到4中描述的上下文切换和同步。如果您在 <em>cross-replica context</em> 中对 <em>mirrored variable</em> 调用 assign，您只能 assign 一个值，或者从一个镜像的 tf.distribution.DistributedValues 中来 assign 值。对于一个 _SyncOnRead 变量，在 <em>replica</em> 上下文中，您可以简单地调用 assign，而不发生任何聚合。在 <em>cross-replica context</em> 中，您只能给一个 SyncOnRead 变量分配一个值。</p>
<h3 id="16-继承关系">1.6 继承关系</h3>
<p>Strategy 继承关系如下，其中 V1 版本是一条路线，V2 版本又是一条路线。</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094742881-1319631970.jpg" alt="" loading="lazy"></p>
<p>图 1 Strategy 继承关系</p>
<p>Extended 继承关系如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094754348-1599984851.jpg" alt="" loading="lazy"></p>
<p>图 2 Extended 继承关系</p>
<p>至此，我们分析了Strategy的类体系，但是还没有领略Strategy的精妙之处，我们需要继续分析下去，本文会先看看如何处理数据，下一篇看看如何处理变量。</p>
<h2 id="2-读取数据">2. 读取数据</h2>
<p>我们接下来看看如何读取数据。对于输入数据集，主要有两种实现：</p>
<ul>
<li>experimental_distribute_dataset ：从 tf.data.Dataset 生成 tf.distribute.DistributedDataset，得到的数据集可以像常规数据集一样迭代读取。</li>
<li>_distribute_datasets_from_function ：通过调用 dataset_fn 来分发 tf.data.Dataset。</li>
</ul>
<p>我们接下来用 MirroredStrategy 来分析如何读取数据。总体的逻辑大致如下：在每个工作者上对数据集进行复制，重新分批和分片。首先会按文件分片，这样每个工作者将看到不同的文件子集。如果无法做到，工作者则将尝试对最终输入进行分片，这样每个工作者会运行整个预处理流水线，但是只收到自己的数据集分片，从而达到数据并行的目的。</p>
<h3 id="21-直接读取数据集">2.1 直接读取数据集</h3>
<h4 id="211-用例">2.1.1 用例</h4>
<p>以下是如何使用 experimental_distribute_dataset 来直接得到数据集。</p>
<pre><code class="language-python">&gt;&gt;&gt; global_batch_size = 2
&gt;&gt;&gt; # Passing the devices is optional.
... strategy = tf.distribute.MirroredStrategy(devices=["GPU:0", "GPU:1"])
&gt;&gt;&gt; # Create a dataset
... dataset = tf.data.Dataset.range(4).batch(global_batch_size)
&gt;&gt;&gt; # Distribute that dataset
... dist_dataset = strategy.experimental_distribute_dataset(dataset)
&gt;&gt;&gt; @tf.function
... def replica_fn(input):
...   return input*2
&gt;&gt;&gt; result = []
&gt;&gt;&gt; # Iterate over the tf.distribute.DistributedDataset
... for x in dist_dataset:
...   # process dataset elements
...   result.append(strategy.run(replica_fn, args=(x,)))
&gt;&gt;&gt; print(result)
[PerReplica:{
  0: &lt;tf.Tensor: shape=(1,), dtype=int64, numpy=array([0])&gt;,
  1: &lt;tf.Tensor: shape=(1,), dtype=int64, numpy=array([2])&gt;
}, PerReplica:{
  0: &lt;tf.Tensor: shape=(1,), dtype=int64, numpy=array([4])&gt;,
  1: &lt;tf.Tensor: shape=(1,), dtype=int64, numpy=array([6])&gt;
}]
</code></pre>
<h4 id="212-基类实现">2.1.2 基类实现</h4>
<p>StrategyBase 方法之中，主要三种数据相关操作是：分批，分片，预取（大家可以回到PyTorch数据读取部分看看异同）。</p>
<p>在上面的代码片段中，<strong>分批</strong>操作具体是：</p>
<ul>
<li>dataset 首先按照 global_batch_size 进行分批。</li>
<li>其次调用 experimental_distribute_dataset 把 dataset 按照一个新分批大小（batch size）进行重新分批，新分批大小等于"全局分批大小除以同步副本数量"。用户可以用 Pythonic for loop 来遍历它。</li>
<li>x 是一个 tf.distribution.DistributedValues，其包含所有副本的数据，而每个副本会得到新批次大小的数据。</li>
<li>tf.distribution.Strategy.run 将负责把 x 中每个副本对应的数据（per-replica）分发给每个副本执行工作函数 replica_fn。</li>
</ul>
<p><strong>分片</strong>（Sharding）包含跨多个工作者的自动分片（autosharding）。</p>
<ul>
<li>首先，在多工作者（multi-worker）分布式训练中（使用tf.distribution.experimental.MultiWorkerMirroredStrategy 或 tf.distribution.TPUStrategy 时），在一组工作者上自动分片（autosharding）数据集意味着每个工作者被分配了整个数据集的一个子集（如果设置了正确的tf.data.experimental.AutoShardPolicy）。这是为了确保在每个 step 中，每个工作者都会处理一个全局的，包含不重叠的数据集元素的批次。自动分片有几个不同的选项，可以使用 tf.data.experimental.DistributeOptions 来指定。</li>
<li>然后，每个工作者内的分片意味着该方法将在所有工作者设备之间分割数据（如果存在多个）。无论多工作者（multi-worker）是否设定自动分片，这都会发生。</li>
<li>对于跨多个工作者的自动分片，默认模式是 tf.data.experimental.AutoShardPolicy.AUTO。如果数据集是从读者数据集（例如tf.data.TFRecordDataset、tf.data.TextLineDataset等）中创建的，该模式将尝试按文件分片，否则按数据分片，其中每个工作者将读取整个数据集，但是只处理分配给它的分片。然而，如果每个工作者的输入文件少于一个，我们建议您通过设置 tf.data.experimental.DistributeOptions.auto_shard_policy 为 tf.data.experimental.AutoShardPolicy.OFF 来禁止跨工作者的数据集自动分片。</li>
</ul>
<p>对于<strong>预取</strong>（prefetch），默认情况下，该方法在用户提供的 tf.data.Dataset 实例的末尾添加一个预取转换。预取转换的参数是 buffer_size，就是同步的副本（replicas in sync）的数量。</p>
<p>experimental_distribute_dataset 的定义如下，其实就是调用 extended 来完成操作。</p>
<pre><code class="language-python">  def experimental_distribute_dataset(self, dataset, options=None):
    """Creates tf.distribute.DistributedDataset from tf.data.Dataset.

    Args:
      dataset: tf.data.Dataset that will be sharded across all replicas using
        the rules stated above.
      options: tf.distribute.InputOptions used to control options on how this
        dataset is distributed.

    Returns:
      A tf.distribute.DistributedDataset.
    """
    distribution_strategy_input_api_counter.get_cell(
        self.__class__.__name__, "distribute_dataset").increase_by(1)

    return self._extended._experimental_distribute_dataset(dataset, options)  
</code></pre>
<h4 id="213-mirroredextended-实现">2.1.3 MirroredExtended 实现</h4>
<p>我们用 MirroredExtended 来看看具体实现，其实就是调用 input_lib.get_distributed_dataset 来进行处理，因此我们深入到 input_lib 之中。</p>
<pre><code class="language-python">def _experimental_distribute_dataset(self, dataset, options):
  if (options and options.experimental_replication_mode ==
      distribute_lib.InputReplicationMode.PER_REPLICA):
    raise NotImplementedError(
        "InputReplicationMode.PER_REPLICA "
        "is only supported in "
        "distribute_datasets_from_function."
    )
  return input_lib.get_distributed_dataset(
      dataset,
      self._input_workers_with_options(options),
      self._container_strategy(),
      num_replicas_in_sync=self._num_replicas_in_sync,
      options=options)
</code></pre>
<h4 id="214-input_lib-功能">2.1.4 input_lib 功能</h4>
<p>input_lib 提供了关于处理输入数据的一些基础功能。get_distributed_dataset 是一个通用函数，其可以被所有策略用来返回分布式数据集。返回的分布式数据集实例是不同的，这取决于我们是在 TF1 还是 TF2 的背景下。返回的分布式数据集实例的 API 也有所不同。这里用到了 DistributedDataset 和 input_workers，所以我们有必要一一进行分析。</p>
<pre><code class="language-python">def get_distributed_dataset(dataset,
                            input_workers,
                            strategy,
                            num_replicas_in_sync=None,
                            input_context=None,
                            options=None,
                            build=True):
  """Returns a distributed dataset from the given tf.data.Dataset instance.

  Args:
    dataset: a tf.data.Dataset instance.
    input_workers: an InputWorkers object which specifies devices on which
        iterators should be created.
    strategy: a tf.distribute.Strategy object, used to run all-reduce to
        handle last partial batch.
    num_replicas_in_sync: Optional integer. If this is not None, the value is
        used to decide how to rebatch datasets into smaller batches so that
        the total batch size for each step (across all workers and replicas)
        adds up to dataset's batch size.
    input_context: InputContext for sharding. Only pass this in for between
        graph multi-worker cases where there is only one input_worker. In
        these cases, we will shard based on the input_pipeline_id and
        num_input_pipelines in the InputContext.
    options: Default is None. tf.distribute.InputOptions used to control
        options on how this dataset is distributed.
    build: whether to build underlying datasets when a DistributedDataset is
        created. This is only useful for ParameterServerStrategy now.

  Returns:
    A distributed dataset instance.
  """
  if tf2.enabled():
    return DistributedDataset( # 接下来会分析 DistributedDataset
        input_workers,
        strategy,
        dataset,
        num_replicas_in_sync=num_replicas_in_sync,
        input_context=input_context,
        build=build,
        options=options)
  else:
    return DistributedDatasetV1(
        dataset,
        input_workers, # 接下来会分析 InputWorkers
        strategy,
        num_replicas_in_sync=num_replicas_in_sync,
        input_context=input_context,
        options=options)

</code></pre>
<h4 id="215-inputworkers">2.1.5 InputWorkers</h4>
<h5 id="定义">定义</h5>
<p>InputWorkers 的作用是从输入 worker 设备到计算设备的 1-to-many mapping。worker_device_pairs 就是映射关系列表，每个 item 是 (input device, a tuple of compute devices fed by that input device)。</p>
<pre><code class="language-python">class InputWorkers(object):
  """A 1-to-many mapping from input worker devices to compute devices."""

  # TODO(ishark): Remove option canonicalize_devices and make all the callers
  # pass canonicalized or raw device strings as relevant from strategy.
  def __init__(self,
               worker_device_pairs,
               canonicalize_devices=True):
    """Initialize an InputWorkers object.

    Args:
      worker_device_pairs: A sequence of pairs: (input device, a tuple of
        compute devices fed by that input device).
      canonicalize_devices: Whether to canonicalize devices for workers fully or
        partially. If False, it will partially canonicalize devices by removing
        job and task.
    """
    self._worker_device_pairs = worker_device_pairs
    self._input_worker_devices = tuple(d for d, _ in self._worker_device_pairs)
    self._canonicalize_devices = canonicalize_devices
    if canonicalize_devices:
      self._fed_devices = tuple(
          tuple(device_util.canonicalize(d)
                for d in f)
          for _, f in self._worker_device_pairs)
    else:
      self._fed_devices = tuple(
          tuple(device_util.canonicalize_without_job_and_task(d)
                for d in f)
          for _, f in self._worker_device_pairs)

  @property
  def num_workers(self):
    return len(self._input_worker_devices)

  @property
  def worker_devices(self):
    return self._input_worker_devices # 返回 device, worker 信息

  def compute_devices_for_worker(self, worker_index):
    return self._fed_devices[worker_index]

  def __repr__(self):
    devices = self.worker_devices
    debug_repr = ",\n".join("  %d %s: %s" %
                            (i, devices[i], self._fed_devices[i])
                            for i in range(len(devices)))
    return "%s:{\n%s}" % (self.__class__.__name__, debug_repr)

  def serialize(self):
    return (self._worker_device_pairs, self._canonicalize_devices)

  def deserialize(self, serialized):
    return InputWorkers(serialized)

</code></pre>
<h5 id="构建">构建</h5>
<p>在 MirroredStrategy 之中有成员变量 _input_workers，因此，如果调用时候就会生成 InputWorkers。</p>
<pre><code class="language-python">@property
def _input_workers(self):
  return self._input_workers_with_options()
</code></pre>
<p>_input_workers_with_options 会根据 self._devices 来进行配置，就是生成各种映射关系，然后配置进去。</p>
<pre><code class="language-python">def _input_workers_with_options(self, options=None):
  if not options: 
    # 没有配置就直接建立
    return input_lib.InputWorkers(self._input_workers_devices)

  # 有配置就依据配置生成
  if (options.experimental_replication_mode ==
      distribute_lib.InputReplicationMode.PER_REPLICA):
    # PER_REPLICA 处理
    if options.experimental_place_dataset_on_device:
      self._input_workers_devices = (
          tuple(
              (device_util.canonicalize(d, d), (d,)) for d in self._devices))
    else:
      self._input_workers_devices = (
          tuple((device_util.canonicalize("/device:CPU:0", d), (d,))
                for d in self._devices))
    return input_lib.InputWorkers(self._input_workers_devices)
  else:
    if not options.experimental_fetch_to_device:
      return input_lib.InputWorkers([
          (host_device, (host_device,) * len(compute_devices))
          for host_device, compute_devices in self._input_workers_devices
      ])
    else:
      return input_lib.InputWorkers(self._input_workers_devices)

</code></pre>
<p>这里使用了 device_util.canonicalize 方法，其作用是把设备分类。</p>
<pre><code class="language-python">def canonicalize(d, default=None):
  """Canonicalize device string.

  If d has missing components, the rest would be deduced from the default
  argument or from '/replica:0/task:0/device:CPU:0'. For example:
    If d = '/cpu:0', default='/job:worker/task:1', it returns
      '/job:worker/replica:0/task:1/device:CPU:0'.
    If d = '/cpu:0', default='/job:worker', it returns
      '/job:worker/replica:0/task:0/device:CPU:0'.
    If d = '/gpu:0', default=None, it returns
      '/replica:0/task:0/device:GPU:0'.

  Note: This uses "job:localhost" as the default if executing eagerly.

  Args:
    d: a device string or tf.config.LogicalDevice
    default: a string for default device if d doesn't have all components.

  Returns:
    a canonicalized device string.
  """
  if isinstance(d, context.LogicalDevice):
    d = tf_device.DeviceSpec.from_string(d.name)
  else:
    d = tf_device.DeviceSpec.from_string(d)

  # Fill in missing device fields using defaults.
  result = tf_device.DeviceSpec(
      replica=0, task=0, device_type="CPU", device_index=0)
  if ops.executing_eagerly_outside_functions():
    # Try to deduce job, replica and task in case it's in a multi worker setup.
    host_cpu = tf_device.DeviceSpec.from_string(
        config.list_logical_devices("CPU")[0].name)
    if host_cpu.job:
      result = result.make_merged_spec(host_cpu)
    else:
      # The default job is localhost if eager execution is enabled
      result = result.replace(job="localhost")
  if default:
    # Overrides any defaults with values from the default device if given.
    result = result.make_merged_spec(
        tf_device.DeviceSpec.from_string(default))

  # Apply d last, so that it's values take precedence over the defaults.
  result = result.make_merged_spec(d)
  return result.to_string()

</code></pre>
<h4 id="216-distributeddataset">2.1.6 DistributedDataset</h4>
<p>DistributedDataset 支持预先分发数据到多个设备。</p>
<h5 id="初始化">初始化</h5>
<p>下面代码中省略了大量检查代码，关键点是调用了 build 方法。</p>
<pre><code class="language-python">class DistributedDataset(_IterableInput, composite_tensor.CompositeTensor):
  """Distributed dataset that supports prefetching to multiple devices."""

  def __init__(self,
               input_workers,
               strategy,
               dataset=None,
               num_replicas_in_sync=None,
               input_context=None,
               components=None,
               element_spec=None,
               enable_get_next_as_optional=None,
               build=True,
               options=None):
    """Distribute the dataset on all workers.

    If num_replicas_in_sync is not None, we split each batch of the dataset
    into num_replicas_in_sync smaller batches, to be distributed among that
    worker's replicas, so that the batch size for a global step (across all
    workers and replicas) is as expected.

    Args:
      input_workers: an InputWorkers object.
      strategy: a tf.distribute.Strategy object, used to run all-reduce to
        handle last partial batch.
      dataset: tf.data.Dataset that will be used as the input source. Either
        dataset or components field should be passed when constructing
        DistributedDataset. Use this when contructing DistributedDataset from a
        new tf.data.Dataset. Use components when constructing using
        DistributedDatasetSpec.
      num_replicas_in_sync: Optional integer. If this is not None, the value
        is used to decide how to rebatch datasets into smaller batches so that
        the total batch size for each step (across all workers and replicas)
        adds up to dataset's batch size.
      input_context: InputContext for sharding. Only pass this in for between
        graph multi-worker cases where there is only one input_worker. In
        these cases, we will shard based on the input_pipeline_id and
        num_input_pipelines in the InputContext.
      components: datasets when DistributedDataset is constructed from
        DistributedDatasetSpec. Either field dataset or components should be
        passed.
      element_spec: element spec for DistributedDataset when constructing from
        DistributedDatasetSpec. This will be used to set the element_spec for
        DistributedDataset and verified against element_spec from components.
      enable_get_next_as_optional: this is required when components is passed
        instead of dataset.
      build: whether to build underlying datasets when this object is created.
        This is only useful for ParameterServerStrategy now.
      options: tf.distribute.InputOptions used to control options on how this
        dataset is distributed.
    """
    super(DistributedDataset, self).__init__(input_workers=input_workers)

    self._input_workers = input_workers
    self._strategy = strategy
    self._options = options
    self._input_context = input_context
    self._num_replicas_in_sync = num_replicas_in_sync

    if dataset is not None:
      self._original_dataset = dataset
      self._built = False
      if build:
        self.build() # 这里是关键
    else:
      self._cloned_datasets = components
      self._cardinality = _cardinality(self._cloned_datasets[0])
      self._enable_get_next_as_optional = enable_get_next_as_optional

      if element_spec != _create_distributed_tensor_spec(
          self._strategy, self._cloned_datasets[0].element_spec):
        raise ValueError("Mismatched element_spec from the passed components")
      self._element_spec = element_spec

      self._built = True

</code></pre>
<h5 id="建立数据">建立数据</h5>
<p>build 主要作用是调用 _create_cloned_datasets_from_dataset。</p>
<pre><code class="language-python">def build(self, dataset_to_replace=None):
  dataset = dataset_to_replace or self._original_dataset
  self._cardinality = _cardinality(dataset)
  self._enable_get_next_as_optional = _enable_get_next_as_optional(
      self._strategy, dataset, self._cardinality)
  self._create_cloned_datasets_from_dataset(dataset, self._input_context,
                                            self._input_workers,
                                            self._strategy,
                                            self._num_replicas_in_sync)
  self._element_spec = _create_distributed_tensor_spec(
      self._strategy, self._cloned_datasets[0].element_spec)
  self._built = True

</code></pre>
<p>_create_cloned_datasets_from_dataset 在每个工作者上对数据集进行克隆和分片（这里就使用到了InputWorkers以获取设备信息）。首先会尝试按文件分片，以便每个工作者看到不同的文件子集。如果无法做到，则将尝试对最终输入进行分片，这样每个工作者将运行整个预处理管道，并且只收到自己的数据集分片。</p>
<p>此外，_create_cloned_datasets_from_dataset 将每个工作者上的数据集重新匹配成 num_replicas_in_sync 个更小的批次。这些更小的批次分布在该工作者的副本中，这样全局步骤（global step）的批次大小（跨越所有工作者和副本）加起来就等于原始数据集的批次大小。</p>
<pre><code class="language-python">def _create_cloned_datasets_from_dataset(self, dataset, input_context,
                                         input_workers, strategy,
                                         num_replicas_in_sync):
  if num_replicas_in_sync is not None:
    num_workers = input_context.num_input_pipelines if input_context else len(
        input_workers.worker_devices)
    # 用 _make_rebatch_fn 来重新 batch 数据
    rebatch_fn = self._make_rebatch_fn(dataset, num_workers,
                                       num_replicas_in_sync)
  else:
    rebatch_fn = None
  self._cloned_datasets = []
  
  if input_context:
    # Between-graph where we rely on the input_context for sharding
    if rebatch_fn is not None:
      dataset = rebatch_fn(dataset, input_context.input_pipeline_id)
    dataset = input_ops.auto_shard_dataset(dataset,
                                           input_context.num_input_pipelines,
                                           input_context.input_pipeline_id,
                                           num_replicas_in_sync)
    self._cloned_datasets.append(dataset)
  else:
    # 复制数据，返回 _RemoteDataset
    replicated_ds = distribute.replicate(dataset,
                                         input_workers.worker_devices)
    
    for i, worker in enumerate(input_workers.worker_devices):
      with ops.device(worker):
        cloned_dataset = replicated_ds[worker] # 找到某 worker 对应的数据集
        if rebatch_fn is not None:
          cloned_dataset = rebatch_fn(cloned_dataset, i) # 重新 batch，返回 _RebatchDataset
        # 自动分区，返回 _AutoShardDataset
        cloned_dataset = input_ops.auto_shard_dataset(
            cloned_dataset, len(input_workers.worker_devices), i,
            num_replicas_in_sync)
        self._cloned_datasets.append(cloned_dataset)

</code></pre>
<p>distribute.replicate 是用来复制数据，把数据复制到一系列设备上，这里返回 _RemoteDataset。</p>
<pre><code class="language-python">def replicate(dataset, devices):
  """A transformation that replicates dataset onto a list of devices.

  Args:
    dataset: A tf.data.Dataset object.
    devices: A list of devices to replicate the dataset on.

  Returns:
    A dictionary mapping device name to a dataset on that device.
  """

  dataset_device = dataset._variant_tensor.device

  datasets = {}
  if len(devices) == 1 and devices[0] == dataset_device:
    datasets[devices[0]] = dataset
    return datasets

  with ops.colocate_with(dataset._variant_tensor):
    dataset = dataset._apply_debug_options()
    graph_def = dataset._as_serialized_graph(
        strip_device_assignment=True,
        external_state_policy=ExternalStatePolicy.WARN)
    
  for device in devices: # 遍历设备，复制数据到设备上，每个设备一个 _RemoteDataset
    ds = _RemoteDataset(graph_def, device, dataset.element_spec)
    datasets[device] = ds
    
  return datasets
</code></pre>
<p>_make_rebatch_fn 返回一个把输入数据集 rebatches 的 callable，这里返回 _RebatchDataset。</p>
<pre><code class="language-python">def _make_rebatch_fn(self, dataset, num_workers, num_replicas_in_sync):
  """Returns a callable that rebatches the input dataset.

  Args:
    dataset: A tf.data.Dataset representing the dataset to be distributed.
    num_workers: An integer representing the number of workers to distribute
      dataset among.
    num_replicas_in_sync: An integer representing the number of replicas in
      sync across all workers.
  """
  if num_replicas_in_sync % num_workers:
    raise ValueError(
        "tf.distribute expects every worker to have the same number of "
        "replicas. However, encountered num_replicas_in_sync ({}) that "
        "cannot be divided by num_workers ({})".format(
            num_replicas_in_sync, num_workers))

  num_replicas_per_worker = num_replicas_in_sync // num_workers
  with ops.colocate_with(dataset._variant_tensor):  
    batch_size = distribute.compute_batch_size(dataset)

  def rebatch_fn(dataset, worker_index):
    try:
      def apply_rebatch():
        batch_sizes = distribute.batch_sizes_for_worker(
            batch_size, num_workers, num_replicas_per_worker, worker_index)
        return distribute._RebatchDataset(
            dataset, batch_sizes).prefetch(num_replicas_per_worker)

      def apply_legacy_rebatch():
        return distribute._LegacyRebatchDataset(
            dataset, num_replicas_in_sync).prefetch(num_replicas_per_worker)

      with ops.colocate_with(dataset._variant_tensor):
        return control_flow_ops.cond(
            math_ops.not_equal(batch_size, -1),
            true_fn=apply_rebatch,
            false_fn=apply_legacy_rebatch)
    except errors.InvalidArgumentError as e:
      if "without encountering a batch" in str(e):
        six.reraise(
            ValueError,
            ValueError(
                "Call the batch method on the input Dataset in order to be "
                "able to split your input across {} replicas.\n Please see "
                "the tf.distribute.Strategy guide. {}".format(
                    num_replicas_in_sync, e)),
            sys.exc_info()[2])
      else:
        raise

  return rebatch_fn

</code></pre>
<p>接下来是自动分片，这里返回 _AutoShardDataset。</p>
<pre><code class="language-python">def auto_shard_dataset(dataset, num_shards, index, num_replicas_in_sync=None):
  """Shard the input pipeline by sharding the underlying list of files.

  Args:
    dataset: A tf.data.Dataset instance, typically the result of a bunch of
      dataset transformations.
    num_shards: A tf.int64 scalar tf.Tensor, representing the number of
        shards operating in parallel. Same usage as in tf.data.Dataset.shard.
    index: A tf.int64 scalar tf.Tensor, representing the worker index.
      Same usage as in tf.data.Dataset.shard.
    num_replicas_in_sync: An integer representing the total number of replicas
      across all workers. This is used in the rewrite when sharding by data.

  Returns:
    A modified Dataset obtained by updating the pipeline sharded by the
    files. The input dataset will be returned if we cannot automatically
    determine a good way to shard the input dataset.
  """
  if (dataset.options().experimental_distribute.auto_shard_policy !=
      AutoShardPolicy.OFF):
    if num_replicas_in_sync is None:
      num_replicas_in_sync = 1
    if isinstance(dataset, dataset_ops.DatasetV1):
      return distribute._AutoShardDatasetV1(dataset, num_shards, index,
                                            num_replicas_in_sync)
    else:
      return distribute._AutoShardDataset(dataset, num_shards, index,
                                          num_replicas_in_sync)
  else:
    return dataset

</code></pre>
<p>此时流程图如下，可以看到数据集功能逐渐加强，首先是 _RemoteDataset，然后升级到 _AutoShardDataset。</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094820133-742408969.jpg" alt="" loading="lazy"></p>
<p>图 3 建立数据集</p>
<h5 id="数据集">数据集</h5>
<p>因为上面涉及了几种数据集，所以我们要再仔细梳理一下这其中的关系，其具体可以理解为在数据集 DatasetV2 基础之上逐步添加功能，最终返回给用户。</p>
<p><strong>_RemoteDataset</strong> 对应远端数据集。</p>
<p>_RemoteDataset  继承了 DatasetSource。dataset_ops.DatasetSource 继承 DatasetV2（就是data.Dataset）。</p>
<pre><code class="language-python">class DatasetSource(DatasetV2):
  """Abstract class representing a dataset with no inputs."""
 
@tf_export("data.Dataset", v1=[])
@six.add_metaclass(abc.ABCMeta)
class DatasetV2(collections_abc.Iterable, tracking_base.Trackable,
                composite_tensor.CompositeTensor):

</code></pre>
<p>具体 _RemoteDataset 如下，其利用with ops.device(device)把数据集设定到远端设备上。</p>
<pre><code class="language-python">class _RemoteDataset(dataset_ops.DatasetSource):
  """Creates a dataset on a given device given a graph def."""

  def __init__(self, graph_def, device, element_spec):
    self._elem_spec = element_spec
    with ops.device(device): # 这里会把数据集设定到远端设备上
      variant_tensor = ged_ops.dataset_from_graph(graph_def)
    super(_RemoteDataset, self).__init__(variant_tensor)

  @property
  def element_spec(self):
    return self._elem_spec

</code></pre>
<p><strong>_RebatchDataset</strong> 代表重新分批，具体使用参见如下：</p>
<pre><code class="language-python">  ds = tf.data.Dataset.range(8)
  ds = ds.batch(4)
  ds = _RebatchDataset(ds, batch_sizes=[2, 1, 1])
  for elem in ds:
    print(elem)
  &gt;&gt; [0, 1], [2], [3], [4, 5], [6], [7]

  ds = tf.data.Dataset.range(16)
  ds = ds.batch(4)
  ds = _RebatchDataset(ds, batch_sizes=[6])
  for elem in ds:
    print(elem)
  &gt;&gt; [0, 1, 2, 3, 4, 5], [6, 7, 8, 9, 10, 11], [12, 13, 14, 15]

</code></pre>
<p>具体代码如下：</p>
<pre><code class="language-python">class _RebatchDataset(dataset_ops.UnaryDataset):
  """A Dataset that rebatches elements from its input into new batch sizes.

  _RebatchDataset(input_dataset, batch_sizes) is functionally equivalent to
  input_dataset.unbatch().batch(N), where the value of N cycles through the
  batch_sizes input list. The elements produced by this dataset have the same
  rank as the elements of the input dataset.

  """

  def __init__(self, input_dataset, batch_sizes, drop_remainder=False):
    """Creates a _RebatchDataset.

    Args:
      input_dataset: Dataset to rebatch.
      batch_sizes: A tf.int64 scalar or vector, representing the size of
        batches to produce. If this argument is a vector, these values are
        cycled through in order.
      drop_remainder: (Optional.) A tf.bool scalar tf.Tensor, representing
        whether the last batch should be dropped in the case it has fewer than
        batch_sizes[cycle_index] elements; the default behavior is not to drop
        the smaller batch.
    """
    self._input_dataset = input_dataset
    self._batch_sizes = ops.convert_to_tensor(
        batch_sizes, dtype=dtypes.int64, name="batch_sizes")
    self._drop_remainder = ops.convert_to_tensor(
        drop_remainder, dtype=dtypes.bool, name="drop_remainder")
    new_batch_dim = self._compute_static_batch_dim()

    self._element_spec = nest.map_structure(
        lambda ts: ts._unbatch()._batch(new_batch_dim),
        dataset_ops.get_structure(input_dataset))

    # auto_shard rewrite assumes that there's normalize_to_dense before
    # rebatch_dataset.
    # LINT.IfChange
    input_dataset = dataset_ops.normalize_to_dense(input_dataset)
    variant_tensor = ged_ops.rebatch_dataset_v2(
        input_dataset._variant_tensor,  
        batch_sizes=batch_sizes,
        drop_remainder=drop_remainder,
        **self._flat_structure)
    super(_RebatchDataset, self).__init__(input_dataset, variant_tensor)

  def _compute_static_batch_dim(self):
    """Computes the static batch dimension of a dataset if it can be determined.

    Given the _RebatchDataset parameters, determines the batch dimension of this
    dataset statically. Returns None if this cannot be determined or is
    variable.

    Returns:
      An integer representing the batch dimension of the dataset. If it cannot
      be determined statically, returns None.

    Raises:
      ValueError: The batch_sizes parameter is malformed, input_dataset is
      not batched, or input_dataset batch sizes are incompatible with each
      other.
    """
    new_batch_dim = tensor_util.constant_value(self._batch_sizes)
    if new_batch_dim is None:
      return None

    if isinstance(new_batch_dim, np.ndarray):
      if len(new_batch_dim.shape) == 1:
        if np.all(new_batch_dim == new_batch_dim[0]):
          new_batch_dim = new_batch_dim[0]
        else:
          return None
      elif len(new_batch_dim.shape) &gt; 1:
        raise ValueError(
            f"Invalid batch_sizes. Expected batch_sizes to be a scalar or "
            f"a vector. Received batch_sizes of rank "
            f"{len(new_batch_dim.shape)}."
        )

    if self._may_form_partial_batches(new_batch_dim):
      return None

    return new_batch_dim

  def _may_form_partial_batches(self, desired_batch_size):
    """Returns whether this dataset may form partial batches."""
    if tensor_util.constant_value(self._drop_remainder):
      return False

    def get_batch_dim(type_spec):
      shape = type_spec._to_legacy_output_shapes()  
      if not isinstance(shape, tensor_shape.TensorShape):
        return None
      if shape.rank is None:
        return None
      return shape.dims[0].value

    input_batch_dims = [
        get_batch_dim(ts)
        for ts in nest.flatten(dataset_ops.get_structure(self._input_dataset))
    ]
    known_input_batch_dims = [d for d in input_batch_dims if d is not None]

    if not known_input_batch_dims:
      return True

    known_input_batch_dims = np.asarray(known_input_batch_dims)

    return known_input_batch_dims[0] % desired_batch_size != 0

  @property
  def element_spec(self):
    return self._element_spec

</code></pre>
<p><strong>_AutoShardDataset</strong> 对数据集自动分片。</p>
<p>这个数据集接收了一个现有的数据集，并尝试自动找出如何在多工作者的情况下使用图来对数据集进行分片。</p>
<ul>
<li>
<p>如果 AutoShardPolicy 设置为 FILE，它就会沿着数据集图向上走，直到找到一个读者数据集（reader dataset），然后在该节点之前插入一个 ShardDataset op，这样每个工作者只能看到一些文件。</p>
</li>
<li>
<p>如果 AutoShardPolicy 设置为 DATA，它会在输入流水线的末端，在 terminal PrefetchDataset（如果有）之前，插入一个 ShardDataset 操作。此外，如果输入管道中有 RebatchDatasetV2，出于正确性考虑，它将被写入 legacy RebatchDataset，因为 RebatchDatasetV2 与数据分片不兼容。</p>
</li>
<li>
<p>如果 AutoShardPolicy 设置为 AUTO，它将尝试进行基于文件的分片。如果找不到读者数据集，它就会退回到进行基于数据的分片。</p>
</li>
<li>
<p>如果 AutoShardPolicy 被设置为 OFF，则不进行处理。</p>
</li>
</ul>
<pre><code class="language-python">class _AutoShardDataset(dataset_ops.UnaryDataset):
  """A Dataset that shards the Dataset automatically.

  This dataset takes in an existing dataset and tries to automatically figure
  out how to shard the dataset in a multi-worker scenario using graph rewrites.

  If the AutoShardPolicy is set to FILE, it walks up the dataset graph until
  it finds a reader dataset, then inserts a ShardDataset op before that node
  so that each worker only sees some files.

  If the AutoShardPolicy is set to DATA, it inserts a ShardDataset op at the
  end of the input pipeline, before any terminal PrefetchDataset if there is
  one. Additionally, if there is a RebatchDatasetV2 in the input pipeline, it
  is written to legacy RebatchDataset for correctness reasons, since
  RebatchDatasetV2 is incompatible with data sharding.

  If the AutoShardPolicy is set to AUTO, it tries to do file-based sharding.
  If it cannot find a reader dataset, it falls back to doing data-based
  sharding.

  If the AutoShardPolicy is set to OFF, it does nothing.

  Attributes:
    num_workers: Total number of workers to shard this dataset across.
    index: The current worker index (out of the total number of workers) this
      dataset is for.
    num_replicas: The total number of replicas across all workers. This is used
      only when sharding by data (either DATA or AUTO) in order to rewrite
      RebatchDatasetV2 to RebatchDataset.

  Raises:
    NotFoundError: If we cannot find a suitable reader dataset to begin
      automatically sharding the dataset.
  """

  def __init__(self, input_dataset, num_workers, index, num_replicas=None):
    self._input_dataset = input_dataset

    self._element_spec = input_dataset.element_spec
    variant_tensor = ged_ops.auto_shard_dataset(
        self._input_dataset._variant_tensor, 
        num_workers=num_workers,
        index=index,
        auto_shard_policy=int(
            input_dataset.options().experimental_distribute.auto_shard_policy),
        num_replicas=num_replicas,
        **self._flat_structure)
    super(_AutoShardDataset, self).__init__(input_dataset, variant_tensor)

  @property
  def element_spec(self):
    return self._element_spec

</code></pre>
<p>在 tensorflow\core\grappler\optimizers\data\auto_shard.cc 之中有如下做自动分片的代码，有兴趣的读者可以自行深入。</p>
<pre><code class="language-cpp">Status ApplyAutoShard(const NodeDef&amp; sink_node, int64_t num_workers,
                      int64_t index, AutoShardPolicy policy,
                      int64_t num_replicas, MutableGraphView* graph,
                      AutoShardPolicy* policy_applied) {
  *policy_applied = policy;
  FunctionLibraryDefinition flib(OpRegistry::Global(),
                                 graph-&gt;graph()-&gt;library());
  switch (policy) {
    case AutoShardPolicy::OFF:
      return Status::OK();
    case AutoShardPolicy::FILE:
      return ShardByFile(sink_node, num_workers, index, &amp;flib, graph);
    case AutoShardPolicy::DATA:
      return ShardByData(sink_node, num_workers, index, num_replicas, graph);
    case AutoShardPolicy::HINT:
      return ShardByHint(sink_node, num_workers, index, num_replicas, graph);
    case AutoShardPolicy::AUTO:
    default:
      Status s = ShardByFile(sink_node, num_workers, index, &amp;flib, graph);
      if (errors::IsNotFound(s)) {
        LOG(WARNING) &lt;&lt; "AUTO sharding policy will apply DATA sharding policy "
                        "as it failed to apply FILE sharding policy because of "
                        "the following reason: "
                     &lt;&lt; s.error_message();
        *policy_applied = AutoShardPolicy::DATA;
        return ShardByData(sink_node, num_workers, index, num_replicas, graph);
      }
      *policy_applied = AutoShardPolicy::FILE;
      return s;
  }
}
</code></pre>
<p>具体关系如下，DistributedDataset 成员变量 _cloned_datasets 列表包括了多个 _AutoShardDataset，每个针对一个 Worker。</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094841685-1747858098.jpg" alt="" loading="lazy"></p>
<p>图 4 数据集关系</p>
<h5 id="迭代数据">迭代数据</h5>
<p>我们接下来看看 DistributedDataset 如何迭代，<strong>iter</strong> 方法会针对每个 worker 建立一个 iterator，最后统一返回一个 DistributedIterator。</p>
<pre><code class="language-python">def __iter__(self):

  canonicalize_devices = getattr(self._strategy, "_canonicalize_devices", True)

  # 会针对每个 worker 建立一个 iterator
  worker_iterators = _create_iterators_per_worker(
      self._cloned_datasets,
      self._input_workers,
      enable_legacy_iterators=False,
      options=self._options,
      canonicalize_devices=canonicalize_devices)
    
  # 统一返回一个 DistributedIterator  
  iterator = DistributedIterator(
      self._input_workers,
      worker_iterators,
      self._strategy,
      cardinality=self._cardinality,
      enable_get_next_as_optional=self._enable_get_next_as_optional,
      options=self._options)
  iterator._element_spec = self._element_spec  # pylint: disable=protected-access

  # When async eager is enabled, sometimes the iterator may not finish
  # initialization before passing to a multi device function, add a sync point
  # here to make sure all underlying iterators are initialized.
  if context.executing_eagerly():
    context.async_wait()

  return iterator

</code></pre>
<p>_create_iterators_per_worker 为每个 worker 建立一个 multidevice iterator。</p>
<pre><code class="language-python">def _create_iterators_per_worker(worker_datasets,
                                 input_workers,
                                 enable_legacy_iterators,
                                 options=None,
                                 canonicalize_devices=False):
  """Create a multidevice iterator on each of the workers."""
  iterators = []
  for i, worker in enumerate(input_workers.worker_devices):
    with ops.device(worker):
      worker_devices = input_workers.compute_devices_for_worker(i)
      if tf2.enabled() and not enable_legacy_iterators:
        iterator = _SingleWorkerOwnedDatasetIterator(
            dataset=worker_datasets[i],
            worker=worker,
            devices=worker_devices,
            options=options,
            canonicalize_devices=canonicalize_devices)
      else:
        iterator = _SingleWorkerDatasetIterator(worker_datasets[i], worker,
                                                worker_devices, options)
      iterators.append(iterator)
  return iterators

</code></pre>
<p>_SingleWorkerDatasetIterator 则会建立 MultiDeviceIterator。</p>
<pre><code class="language-python">class _SingleWorkerDatasetIterator(_SingleWorkerDatasetIteratorBase):
  """Iterator for a single DistributedDatasetV1 instance."""

  def _make_iterator(self):
    """Make appropriate iterator on the dataset."""
    with ops.device(self._worker):
      if self._options is not None:
        self._iterator = multi_device_iterator_ops.MultiDeviceIterator(
            self._dataset,
            self._devices,
            max_buffer_size=self._options.experimental_per_replica_buffer_size,
            prefetch_buffer_size=self._options
            .experimental_per_replica_buffer_size)
      else:
        self._iterator = multi_device_iterator_ops.MultiDeviceIterator(
            self._dataset,
            self._devices,
        )

  def initialize(self):
    """Initialize underlying iterator.

    In eager execution, this simply recreates the underlying iterator.
    In graph execution, it returns the initializer ops for the underlying
    iterator.

    Returns:
      A list of any initializer ops that should be run.
    """
    if ops.executing_eagerly_outside_functions():
      self._iterator._eager_reset()  # pylint: disable=protected-access
      return []
    else:
      return [self._iterator.initializer]

  @property
  def output_classes(self):
    return dataset_ops.get_legacy_output_classes(self._iterator)

  @property
  def output_shapes(self):
    return dataset_ops.get_legacy_output_shapes(self._iterator)

  @property
  def output_types(self):
    return dataset_ops.get_legacy_output_types(self._iterator)

</code></pre>
<p>具体逻辑如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094853435-1328849167.jpg" alt="" loading="lazy"></p>
<p>图 5 获取迭代器</p>
<h4 id="217-distributediterator">2.1.7 DistributedIterator</h4>
<p>我们接下来看 DistributedIterator。</p>
<h5 id="distributediterator">DistributedIterator</h5>
<p>DistributedIterator 其实没有完成多少实际工作，主要功能是在基类 DistributedIteratorBase。</p>
<pre><code class="language-python">class DistributedIterator(DistributedIteratorBase,
                          composite_tensor.CompositeTensor):
  """Input Iterator for a distributed dataset."""

  def __init__(self,
               input_workers=None,
               iterators=None,
               strategy=None,
               components=None,
               element_spec=None,
               cardinality=cardinality_lib.UNKNOWN,
               enable_get_next_as_optional=False,
               options=None):

    error_message = ("Either input_workers or "
                     "both components and element_spec need to be "
                     "provided.")
    self._options = options

    if iterators is None:
      if (components is None or element_spec is None):
        raise ValueError(error_message)
      self._element_spec = element_spec
      self._input_workers = input_workers
      self._iterators = components
      self._strategy = strategy
      self._cardinality = cardinality
      self._enable_get_next_as_optional = enable_get_next_as_optional
    else:
      if (components is not None and element_spec is not None):
        raise ValueError(error_message)

      super(DistributedIterator,
            self).__init__(input_workers, iterators, strategy, cardinality,
                           enable_get_next_as_optional)

  @property
  def element_spec(self):
    # When partial batch handling is enabled, always set the batch dimension to
    # None, otherwise we just follow element_spec of the underlying dataset
    # (whose batch dimension may also be None). This is because with partial
    # batching handling we could always produce empty batches.
    if (self._enable_get_next_as_optional and
        self._strategy.extended._in_multi_worker_mode()):  # pylint: disable=protected-access
      return nest.map_structure(
          _rebatch_as_dynamic, self._element_spec, expand_composites=False)
    return self._element_spec

  @property
  def _type_spec(self):
    # Note that we use actual element_spec instead of the rebatched-as-dynamic
    # one to create DistributedIteratorSpec, to be consistent with the
    # underlying iterators' specs.
    return DistributedIteratorSpec(self._input_workers, self._element_spec,
                                   self._strategy,
                                   self._options,
                                   self._cardinality,
                                   self._enable_get_next_as_optional)

</code></pre>
<h5 id="distributediteratorbase">DistributedIteratorBase</h5>
<p>DistributedIteratorBase 的主要方法和普通迭代器相同。</p>
<pre><code class="language-python">class DistributedIteratorBase(DistributedIteratorInterface):
  """Common implementation for all input iterators."""

  # pylint: disable=super-init-not-called
  def __init__(self, input_workers, iterators, strategy, cardinality,
               enable_get_next_as_optional):

    self._iterators = iterators
    self._input_workers = input_workers
    self._strategy = strategy
    self._cardinality = cardinality
    self._enable_get_next_as_optional = enable_get_next_as_optional

  def next(self):
    return self.__next__()

  def __next__(self):
    try:
      return self.get_next()
    except errors.OutOfRangeError:
      raise StopIteration

  def __iter__(self):
    return self

</code></pre>
<p>get_next 完成了获取数据功能，具体我们关注一下 _create_per_replica，这里看起来和分布式最为相关，具体是：</p>
<ul>
<li>找到所有 worker 信息。</li>
<li>计算副本数目。</li>
<li>获取数据，并且重新组合。</li>
</ul>
<pre><code class="language-python">def get_next(self, name=None):
  """Returns the next input from the iterator for all replicas."""
  with distribution_strategy_context.enter_or_assert_strategy(
      self._strategy):

  if not self._enable_get_next_as_optional:
    return self._get_next_no_partial_batch_handling(name)

  optional_list = []
  # 找到 worker 信息
  for i, worker in enumerate(self._input_workers.worker_devices):
    with ops.device(worker):
      optional_list.append(self._iterators[i].get_next_as_optional_list())
      
  # 计算副本数目    
  num_replicas_with_values = _calculate_replicas_with_values(
      self._strategy, self._input_workers, optional_list)

  # 获取数据，并且重新组合
  def _value_or_dummy():
    value_list = _get_value_or_dummy( # 获取数据
        self._input_workers, optional_list, produce_dummy=True)
    return _create_per_replica(value_list, self._strategy)

  def _eof():
    # Optional.get_value raises InvalidArgumentError when there's no value,
    # so we need to call GetNext to raise EOFError.
    return self._get_next_no_partial_batch_handling()

  return control_flow_ops.cond(
      num_replicas_with_values &gt; 0, _value_or_dummy, _eof, strict=True)

</code></pre>
<p>_calculate_replicas_with_values 计算出有数据的副本数目。</p>
<pre><code class="language-python">def _calculate_replicas_with_values(strategy, input_workers, optional_list):
  """Calcualates the number of replicas that have values.

  Args:
    strategy: the tf.distribute.Strategy.
    input_workers: the InputWorkers.
    optional_list: a list of lists tf.experimental.Optional. The values from
      each compute device grouped by the input device.

  Returns:
    A scalar Tensor.
  """
  worker_has_values = []
  for worker, optionals in zip(input_workers.worker_devices, optional_list):
    with ops.device(worker):
      device_has_values = [
          math_ops.cast(v.has_value(), dtypes.int64) for v in optionals
      ]
      worker_has_values.append(
          math_ops.reduce_sum(device_has_values, keepdims=True))
  client_has_values = math_ops.reduce_sum(worker_has_values, keepdims=True)
  if strategy.extended._in_multi_worker_mode():  
    global_has_values = strategy.reduce(
        reduce_util.ReduceOp.SUM, client_has_values, axis=None)
    return array_ops.reshape(global_has_values, [])
  else:
    return array_ops.reshape(client_has_values, [])

</code></pre>
<p>_get_value_or_dummy 获取具体数据。</p>
<pre><code class="language-python">def _get_value_or_dummy(input_workers, optional_list, produce_dummy):
  """Returns the value of the optionals or dummy values.

  Args:
    input_workers: the InputWorkers.
    optional_list: a list of lists tf.experimental.Optional. The values from
      each compute device grouped by the input device.
    produce_dummy: a bool. Whether to produce dummy tensors when the optional
      doesn't have a value.

  Returns:
    A flatten list of Tensors.

  """
  value_list = []
  for i, worker in enumerate(input_workers.worker_devices): # 遍历 worker
    with ops.device(worker):
      devices = input_workers.compute_devices_for_worker(i) # 遍历 worker 之中的设备
      for j, device in enumerate(devices):
        with ops.device(device):
          if produce_dummy:
            value_list.append( # 累计数据
                control_flow_ops.cond(
                    optional_list[i][j].has_value(),
                    lambda: optional_list[i][j].get_value(),  
                    lambda: _dummy_tensor_fn(optional_list[i][j].element_spec),
                    strict=True,
                ))
          else:
            value_list.append(optional_list[i][j].get_value())
  return value_list

</code></pre>
<p>_create_per_replica 完成了具体数据的重新组合。</p>
<ul>
<li>对于 OneDeviceStrategy 以外的策略，它会创建一个 PerReplica，其类型规格被设置为数据集的元素规格。这有助于避免对部分批次进行回溯。当多个客户在不同的时间回溯时，回溯对于多客户端来说是有问题的，因为回溯改变了 tf.function 的集合键（collective keys），并导致客户之间的不匹配。</li>
<li>对于单客户策略，_create_per_replica 只是调用 distribution_utils.regroup()。</li>
</ul>
<pre><code class="language-python">def _create_per_replica(value_list, strategy):
  """Creates a PerReplica.

  For strategies other than OneDeviceStrategy, it creates a PerReplica whose
  type spec is set to the element spec of the dataset. This helps avoid
  retracing for partial batches. Retracing is problematic for multi client when
  different client retraces different time, since retracing changes the
  collective keys in the tf.function, and causes mismatches among clients.

  For single client strategies, this simply calls distribute_utils.regroup().

  Args:
    value_list: a list of values, one for each replica.
    strategy: the tf.distribute.Strategy.

  Returns:
    a structure of PerReplica.

  """
  always_wrap = _always_wrap(strategy)
  per_replicas = distribute_utils.regroup(value_list, always_wrap=always_wrap)
  return per_replicas

</code></pre>
<p>具体逻辑如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094905240-802186241.jpg" alt="" loading="lazy"></p>
<p>图 6 迭代器处理数据</p>
<p>至此，对于读取数据我们其实已经有了一个比较基础的分析，其中最主要几个类之间的逻辑如下：</p>
<ul>
<li>InputWorker 的作用是从输入 worker 设备到计算设备的 1-to-many mapping，可以认为 InputWorker 把 worker 绑定到设备之上。</li>
<li>DistributedDataset 就是数据集了，其内部有一系列复杂处理，首先把数据集复制到一系列设备上，然后对数据集进行一系列加强，首先是 _RemoteDataset，然后升级到 _AutoShardDataset。</li>
<li>DistributedDataset 的 <strong>iter</strong> 方法会针对每个 worker 建立一个 iterator，最后统一返回一个 DistributedIterator。</li>
<li>DistributedIterator 的 get_next 方法完成了获取数据功能，用 _create_per_replica 来举例， 具体操作是:
<ul>
<li>找到所有 worker 信息。</li>
<li>计算副本数目。</li>
<li>获取数据，并且重新组合。</li>
</ul>
</li>
</ul>
<p>具体如下图（只是大致逻辑概念，仅仅为了更好的说明），数字与下图之中对应。</p>
<ul>
<li>1.InputWorkers 提供了worker和设备的映射关系。</li>
<li>2.数据集被分配到各个设备或者说worker之上。</li>
<li>3.每个 worker 建立一个 iterator，最后统一返回一个 DistributedIterator。</li>
</ul>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094925512-1593160379.jpg" alt="" loading="lazy"></p>
<h3 id="22-通过方法初始化">2.2 通过方法初始化</h3>
<p>如果上述的批量分割和数据集分片逻辑（即，直接读取数据集逻辑）不能满足需求，用户可以使用tf.distribution.Strategy.distribution_datasets_from_function，它不会做任何自动的批量分割或分片。</p>
<h4 id="221-strategybase">2.2.1 StrategyBase</h4>
<p>我们首先来到 StrategyBase。distribute_datasets_from_function 会分发 tf.data.Dataset，这些实例是通过执行dataset_fn 来创建的。</p>
<p>用户传入的参数 dataset_fn 是一个输入函数，它有 tf.distribution.InputContext 参数，并返回一个 tf.data.Dataset 实例。从 dataset_fn 返回的数据集默认已经按每个副本的批处理量（即全局批处理量除以同步的副本数量）进行分批，也进行了分片处理。</p>
<p>tf.distribution.Strategy.distribution_datasets_from_function 不会对输入函数返回的 tf.dataset 实例进行批处理或分片。dataset_fn 将在每个 worker 的 CPU 设备上被调用，每次调用都会生成一个数据集，在此调用之中，该 worker 的每个副本都会从数据集获取一批输入（例如，如果一个 worke r有两个副本，每一步都会从 Dataset 中提取两个批次）。在几种情况下会使用这个方法。</p>
<ul>
<li>首先，它允许您指定您自己的批处理和分片逻辑，相比之下，tf.distribution.experimental_distribute_dataset 会为您做批处理和分片。例如，当 experimental_distribute_dataset 无法对输入文件进行分片时，可以用这个方法来手动分片（避免 experimental_distribute_dataset 的缓慢回退行为）。</li>
<li>在无限数据集的情况下，可以通过创建数据集副本来完成分片，这些副本只在随机种子上有所不同。</li>
</ul>
<p>dataset_fn 应该接受一个 tf.distribution.InputContext 实例，此实例包括了关于批处理和输入副本的信息。由dataset_fn 返回的 tf.data.Dataset 应该有一个每副本（per-replica）的批次大小，这与 experimental_distribute_dataset 不同，后者使用全局批次大小。全局批次大小可以通过 input_context.get_per_replica_batch_size 来计算得到。</p>
<pre><code class="language-python">def distribute_datasets_from_function(self, dataset_fn, options=None):
  """
  Args:
    dataset_fn: A function taking a tf.distribute.InputContext instance and
      returning a tf.data.Dataset.
    options: tf.distribute.InputOptions used to control options on how this
      dataset is distributed.

  Returns:
    A tf.distribute.DistributedDataset.
  """
  distribution_strategy_input_api_counter.get_cell(
      self.__class__.__name__,
      "distribute_datasets_from_function").increase_by(1)

  return self._extended._distribute_datasets_from_function(  
      dataset_fn, options)

</code></pre>
<h4 id="222-mirroredstrategy">2.2.2 MirroredStrategy</h4>
<p>我们依然用MirroredStrategy作为例子来看。_distribute_datasets_from_function 这里会初始化 Input worker，然后配置上下文，读取数据。</p>
<pre><code class="language-python">def _distribute_datasets_from_function(self, dataset_fn, options):
  input_workers = self._input_workers_with_options(options) # 构建 InputWorkers
  input_contexts = []
  num_workers = input_workers.num_workers
  for i in range(num_workers):
    input_contexts.append(distribute_lib.InputContext(
        num_input_pipelines=num_workers,
        input_pipeline_id=i,
        num_replicas_in_sync=self._num_replicas_in_sync))

  return input_lib.get_distributed_datasets_from_function(
      dataset_fn, input_workers, input_contexts, self._container_strategy(),
      options)

</code></pre>
<h4 id="223-建立-inputworkers">2.2.3 建立 InputWorkers</h4>
<p>_input_workers_with_options 建立了 InputWorkers。</p>
<pre><code class="language-python">def _input_workers_with_options(self, options=None):
  if not options:
    return input_lib.InputWorkers(self._input_workers_devices)
  if (options.experimental_replication_mode ==
      distribute_lib.InputReplicationMode.PER_REPLICA):
    if options.experimental_place_dataset_on_device:
      self._input_workers_devices = (
          tuple(
              (device_util.canonicalize(d, d), (d,)) for d in self._devices))
    else:
      self._input_workers_devices = (
          tuple((device_util.canonicalize("/device:CPU:0", d), (d,))
                for d in self._devices))
    return input_lib.InputWorkers(self._input_workers_devices)
  else:
    if not options.experimental_fetch_to_device:
      return input_lib.InputWorkers([
          (host_device, (host_device,) * len(compute_devices))
          for host_device, compute_devices in self._input_workers_devices
      ])
    else:
      return input_lib.InputWorkers(self._input_workers_devices)

</code></pre>
<h4 id="224-input_contexts">2.2.4 input_contexts</h4>
<p>input_contexts 是一个包装输入函数所需信息的类，是一个传递给用户输入函数的上下文类，包含了关于计算副本和输入流水线的信息。</p>
<ul>
<li>
<p>利用计算副本的数量（同步训练中）可以让我们从每个副本所需的全局批次大小中计算出本地批次大小。</p>
</li>
<li>
<p>利用输入流水线的信息则可以用来在每个副本中返回不同的输入子集（例如，分片输入流水线，使用不同的 input 源等）。</p>
</li>
</ul>
<pre><code class="language-python">@tf_export("distribute.InputContext")
class InputContext(object):
  """A class wrapping information needed by an input function.

  This is a context class that is passed to the user's input function and
  contains information about the compute replicas and input pipelines. The
  number of compute replicas (in sync training) helps compute the local batch
  size from the desired global batch size for each replica. The input pipeline
  information can be used to return a different subset of the input in each
  replica (for e.g. shard the input pipeline, use a different input
  source etc).
  """

  __slots__ = [
      "_num_input_pipelines", "_input_pipeline_id", "_num_replicas_in_sync"
  ]

  def __init__(self,
               num_input_pipelines=1,
               input_pipeline_id=0,
               num_replicas_in_sync=1):
    """Initializes an InputContext object.

    Args:
      num_input_pipelines: the number of input pipelines in a cluster.
      input_pipeline_id: the current input pipeline id, should be an int in
        [0,num_input_pipelines).
      num_replicas_in_sync: the number of replicas that are in sync.
    """
    self._num_input_pipelines = num_input_pipelines
    self._input_pipeline_id = input_pipeline_id
    self._num_replicas_in_sync = num_replicas_in_sync

  @property
  def num_replicas_in_sync(self):
    """Returns the number of compute replicas in sync."""
    return self._num_replicas_in_sync

  @property
  def input_pipeline_id(self):
    """Returns the input pipeline ID."""
    return self._input_pipeline_id

  @property
  def num_input_pipelines(self):
    """Returns the number of input pipelines."""
    return self._num_input_pipelines

  def get_per_replica_batch_size(self, global_batch_size):
    """Returns the per-replica batch size.

    Args:
      global_batch_size: the global batch size which should be divisible by
        num_replicas_in_sync.

    Returns:
      the per-replica batch size.

    Raises:
      ValueError: if global_batch_size not divisible by
        num_replicas_in_sync.
    """
    if global_batch_size % self._num_replicas_in_sync != 0:
      raise ValueError("The global_batch_size %r is not divisible by "
                       "num_replicas_in_sync %r " %
                       (global_batch_size, self._num_replicas_in_sync))
    return global_batch_size // self._num_replicas_in_sync

  def __str__(self):
    return "tf.distribute.InputContext(input pipeline id {}, total: {})".format(
        self.input_pipeline_id, self.num_input_pipelines)

</code></pre>
<h4 id="225--返回数据集">2.2.5  返回数据集</h4>
<p>get_distributed_datasets_from_function 从给定的输入函数返回一个分布式数据集。这是一个通用函数，所有策略都使用它来返回分布式数据集。取决于在 TF 1 还是 TF 2 的背景下而返回不同的分布式数据集实例，从而分布式数据集实例的 API 也有所不同。</p>
<pre><code class="language-python">def get_distributed_datasets_from_function(dataset_fn,
                                           input_workers,
                                           input_contexts,
                                           strategy,
                                           options=None):
  """Returns a distributed dataset from the given input function.

  This is a common function that is used by all strategies to return a
  distributed dataset. The distributed dataset instance returned is different
  depending on if we are in a TF 1 or TF 2 context. The distributed dataset
  instances returned differ from each other in the APIs supported by each of
  them.

  Args:
    dataset_fn: a function that returns a tf.data.Dataset instance.
    input_workers: an InputWorkers object which specifies devices on which
        iterators should be created.
    input_contexts: A list of InputContext instances to be passed to call(s)
        to dataset_fn. Length and order should match worker order in
        worker_device_pairs.
    strategy: a tf.distribute.Strategy object, used to run all-reduce to
        handle last partial batch.
    options: Default is None. tf.distribute.InputOptions used to control
        options on how this dataset is distributed.

  Returns:
    A distributed dataset instance.

  Raises:
    ValueError: if options.experimental_replication_mode and
    options.experimental_place_dataset_on_device are not consistent
  """

  if tf2.enabled():
    return DistributedDatasetsFromFunction(input_workers, strategy,
                                           input_contexts, dataset_fn, options)
  else:
    return DistributedDatasetsFromFunctionV1(input_workers, strategy,
                                             input_contexts, dataset_fn,
                                             options)

</code></pre>
<h4 id="226-构建数据集">2.2.6 构建数据集</h4>
<p>DistributedDatasetsFromFunction 会调用 _create_datasets_from_function_with_input_context。</p>
<pre><code class="language-python">class DistributedDatasetsFromFunction(_IterableInput,
                                      composite_tensor.CompositeTensor):
  """Inputs created from dataset function."""

  def __init__(self,
               input_workers,
               strategy,
               input_contexts=None,
               dataset_fn=None,
               options=None,
               components=None,
               element_spec=None):
    """Makes an iterable from datasets created by the given function.

    Args:
      input_workers: an InputWorkers object.
      strategy: a tf.distribute.Strategy object, used to run all-reduce to
        handle last partial batch.
      input_contexts: A list of InputContext instances to be passed to call(s)
        to dataset_fn. Length and order should match worker order in
        worker_device_pairs.
      dataset_fn: A function that returns a Dataset given an InputContext.
        Either dataset_fn or components should be passed to construct
        DistributedDatasetsFromFunction. Use this when constructing
        DistributedDataset using a function. Use components when constructing
        using DistributedDatasetsFromFunctionSpec.
      options: tf.distribute.InputOptions used to control options on how this
        dataset is distributed.
      components: datasets when DistributedDatasetsFromFunction is constructed
        from DistributedDatasetsFromFunctionSpec. Only one of dataset or
        components should be passed.
      element_spec: element spec for DistributedDataset when constructing from
        DistributedDatasetSpec. This will be used to set the element_spec for
        DistributedDatasetsFromFunctionSpec and verified against element_spec
        from components.
    """
    super(DistributedDatasetsFromFunction, self).__init__(
        input_workers=input_workers)
    self._input_workers = input_workers
    self._strategy = strategy
    self._options = options

    if dataset_fn is not None:
      self._datasets, element_spec = (
          _create_datasets_from_function_with_input_context(
              input_contexts, self._input_workers, dataset_fn))
      self._element_spec = _create_distributed_tensor_spec(
          self._strategy, element_spec)
    else:
      self._element_spec = element_spec
      self._datasets = components

    self._enable_get_next_as_optional = _enable_get_next_as_optional(
        self._strategy, self._datasets[0])

</code></pre>
<p>_create_datasets_from_function_with_input_context 函数会正式构建数据集。</p>
<pre><code class="language-python">def _create_datasets_from_function_with_input_context(input_contexts,
                                                      input_workers,
                                                      dataset_fn):
  """Create device datasets per worker given a dataset function."""
  datasets = []
  for i, ctx in enumerate(input_contexts): #遍历上下文
    worker = input_workers.worker_devices[i] # 遍历 worker
    with ops.device(worker):
      dataset = dataset_fn(ctx) # 获取数据
      datasets.append(dataset)
  return datasets, dataset.element_spec

</code></pre>
<p>具体逻辑如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412095003937-2091137965.jpg" alt="" loading="lazy"></p>
<p>图 7 通过方法构建数据</p>
<h3 id="23-高层使用">2.3 高层使用</h3>
<h4 id="231-keras">2.3.1 Keras</h4>
<p>我们首先看看 Keras 之中的使用。在 tensorflow/python/keras/distribute/distributed_training_utils_v1.py 之中有如下方法，这里会生成策略的数据迭代器。</p>
<pre><code class="language-python">def get_iterator(dataset, distribution_strategy):
  with distribution_strategy.scope():
    iterator = distribution_strategy.make_dataset_iterator(dataset)
  initialize_iterator(iterator, distribution_strategy)
  return iterator

</code></pre>
<p>tensorflow/python/distribute/distribute_lib.py 则会使用 _extended，比如 StrategyBase 有：</p>
<pre><code class="language-python">def make_dataset_iterator(self, dataset):
  """DEPRECATED TF 1.x ONLY."""
  return self._extended._make_dataset_iterator(dataset)  

</code></pre>
<p>对于 StrategyV1 有：</p>
<pre><code class="language-python">def make_dataset_iterator(self, dataset):
  """Makes an iterator for input provided via dataset.

  DEPRECATED: This method is not available in TF 2.x.

  Data from the given dataset will be distributed evenly across all the
  compute replicas. We will assume that the input dataset is batched by the
  global batch size. With this assumption, we will make a best effort to
  divide each batch across all the replicas (one or more workers).
  If this effort fails, an error will be thrown, and the user should instead
  use make_input_fn_iterator which provides more control to the user, and
  does not try to divide a batch across replicas.

  The user could also use make_input_fn_iterator if they want to
  customize which input is fed to which replica/worker etc.

  Args:
    dataset: tf.data.Dataset that will be distributed evenly across all
      replicas.

  Returns:
    An tf.distribute.InputIterator which returns inputs for each step of the
    computation.  User should call initialize on the returned iterator.
  """
  return self._extended._make_dataset_iterator(dataset) 

</code></pre>
<p>来到 tensorflow/python/distribute/mirrored_strategy.py，则有如下代码生成 DatasetIterator：</p>
<pre><code class="language-python">def _make_dataset_iterator(self, dataset):
  return input_lib.DatasetIterator(
      dataset,
      self._input_workers,
      self._container_strategy(),
      num_replicas_in_sync=self._num_replicas_in_sync)

</code></pre>
<p>具体逻辑如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094936332-666885539.jpg" alt="" loading="lazy"></p>
<p>图 9 Keras 使用</p>
<h4 id="222-其他路径">2.2.2 其他路径</h4>
<p>另一条执行路径如下：</p>
<pre><code class="language-python">def single_loss_example(optimizer_fn, distribution, use_bias=False,
                        iterations_per_step=1):
  """Build a very simple network to use in tests and examples."""

  def dataset_fn():
    return dataset_ops.Dataset.from_tensors([[1.]]).repeat()

  optimizer = optimizer_fn()
  layer = core.Dense(1, use_bias=use_bias)

  def loss_fn(ctx, x):
    del ctx
    y = array_ops.reshape(layer(x), []) - constant_op.constant(1.)
    return y * y

  single_loss_step = step_fn.StandardSingleLossStep(
      dataset_fn, loss_fn, optimizer, distribution, iterations_per_step)

</code></pre>
<p>StandardSingleLossStep 调用如下：</p>
<pre><code class="language-python">class StandardSingleLossStep(StandardInputStep):
  """A step function that implements a training step for a feed forward network.

  An instance of this class is intended to be used as a callable:

  ```python
  ...
  step = step_fn.StandardSingleLossStep(
      dataset, loss_fn, optimizer, distribution)

  # Run a single training step on a given DistributionStrategy:
  step(distribution)
  ...
  ```

  Args:
    dataset_fn: a function that returns a tf.data Dataset that produces the
      input for the model.
    loss_fn: a function that takes a context and inputs as arguments. It returns
      the loss for those inputs. context is an instance of
      values.MultiStepContext that will be passed when loss_fn is run.
      context can be used to specify the outputs to be returned from
      loss_fn, among other things.
    optimizer: an optimizer that implements an update rule.
    distribution: a DistributionStrategy object.
  """

  def __init__(self, dataset_fn, loss_fn, optimizer, distribution,
               iterations_per_step=1):
    super(StandardSingleLossStep, self).__init__(dataset_fn, distribution)
    self._loss_fn = loss_fn
    self._optimizer = optimizer
    self._iterations_per_step = iterations_per_step

  def __call__(self):
    with self._distribution.scope():
      def step_fn(ctx, inputs):
        """Function to run one iteration with one input."""
        gradients_fn = backprop.implicit_grad(self._loss_fn)
        gradients_fn = optimizer_lib.get_filtered_grad_fn(gradients_fn)

        grads_and_vars = self.distribution.extended.call_for_each_replica(
            gradients_fn, args=(ctx, inputs))
        # If threads use layers, then we need to run the first step
        # sequentially, so that layers.build() is not executed in parallel.
        # Otherwise, multiple sets of mirrored variables are going to be
        # created.
        return self._optimizer._distributed_apply(  # pylint: disable=protected-access
            self.distribution, grads_and_vars)

      ctx = self.distribution.extended.experimental_run_steps_on_iterator(
          step_fn, self._iterator, self._iterations_per_step)
      return ctx.run_op

</code></pre>
<p>StandardInputStep 这里生成了 _iterator。</p>
<pre><code class="language-python">class StandardInputStep(Step):
  """Step with a standard implementation of input handling.

  Args:
    dataset_fn: a function that returns a tf.data Dataset that produces the
      input for the model.
  """

  def __init__(self, dataset_fn, distribution):
    super(StandardInputStep, self).__init__(distribution)
    self._iterator = distribution.make_input_fn_iterator(lambda _: dataset_fn())

  def initialize(self):
    return self._iterator.initializer

</code></pre>
<p>StrategyV1之中有：</p>
<pre><code class="language-python">def make_input_fn_iterator(self,  # pylint: disable=useless-super-delegation
                           input_fn,
                           replication_mode=InputReplicationMode.PER_WORKER):
  """Returns an iterator split across replicas created from an input function.

  DEPRECATED: This method is not available in TF 2.x.

  The input_fn should take an tf.distribute.InputContext object where
  information about batching and input sharding can be accessed:

  ```
  def input_fn(input_context):
    batch_size = input_context.get_per_replica_batch_size(global_batch_size)
    d = tf.data.Dataset.from_tensors([[1.]]).repeat().batch(batch_size)
    return d.shard(input_context.num_input_pipelines,
                   input_context.input_pipeline_id)
  with strategy.scope():
    iterator = strategy.make_input_fn_iterator(input_fn)
    replica_results = strategy.experimental_run(replica_fn, iterator)
  ```

  The tf.data.Dataset returned by input_fn should have a per-replica
  batch size, which may be computed using
  input_context.get_per_replica_batch_size.

  Args:
    input_fn: A function taking a tf.distribute.InputContext object and
      returning a tf.data.Dataset.
    replication_mode: an enum value of tf.distribute.InputReplicationMode.
      Only PER_WORKER is supported currently, which means there will be
      a single call to input_fn per worker. Replicas will dequeue from the
      local tf.data.Dataset on their worker.

  Returns:
    An iterator object that should first be .initialize()-ed. It may then
    either be passed to strategy.experimental_run() or you can
    iterator.get_next() to get the next value to pass to
    strategy.extended.call_for_each_replica().
  """
  return super(StrategyV1, self).make_input_fn_iterator(
      input_fn, replication_mode)

</code></pre>
<p>StrategyBase 之中有：</p>
<pre><code class="language-python">@doc_controls.do_not_generate_docs  # DEPRECATED: TF 1.x only
def make_input_fn_iterator(self,
                           input_fn,
                           replication_mode=InputReplicationMode.PER_WORKER):
  """DEPRECATED TF 1.x ONLY."""
  if replication_mode != InputReplicationMode.PER_WORKER:
    raise ValueError(
        "Input replication mode not supported: %r" % replication_mode)
  with self.scope():
    return self.extended._make_input_fn_iterator(  # pylint: disable=protected-access
        input_fn, replication_mode=replication_mode)

</code></pre>
<p>最终来到 MirroredStrategy，生成了 InputFunctionIterator，其调用关系如下：</p>
<pre><code class="language-python">class InputFunctionIterator(DistributedIteratorV1)
class DistributedIteratorV1(DistributedIteratorBase)

</code></pre>
<p>具体代码如下：</p>
<pre><code class="language-python">def _make_input_fn_iterator(
    self,
    input_fn,
    replication_mode=distribute_lib.InputReplicationMode.PER_WORKER):
  input_contexts = []
  num_workers = self._input_workers.num_workers
  for i in range(num_workers):
    input_contexts.append(distribute_lib.InputContext(
        num_input_pipelines=num_workers,
        input_pipeline_id=i,
        num_replicas_in_sync=self._num_replicas_in_sync))
  return input_lib.InputFunctionIterator(input_fn, self._input_workers,
                                         input_contexts,
                                         self._container_strategy())

</code></pre>
<p>逻辑如下：</p>
<p><img src="https://img2022.cnblogs.com/blog/1850883/202204/1850883-20220412094946563-1827723705.jpg" alt="" loading="lazy"></p>
<p>图 10  使用示例</p>
<h2 id="0xff-参考">0xFF 参考</h2>
<p><a href="https://www.cnblogs.com/jicanghai/p/9665689.html" target="_blank">tensorflow源码解析之distributed_runtime</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/141177382" target="_blank" rel="noopener nofollow">TensorFlow分布式训练</a></p>
<p><a href="https://www.jianshu.com/p/fda4ae1e2547" target="_blank" rel="noopener nofollow">TensorFlow内核剖析</a></p>
<p><a href="https://github.com/horance-liu/tensorflow-internals" target="_blank" rel="noopener nofollow">源代码</a></p>
<p><a href="https://www.jianshu.com/p/6fa7c5ef5266" target="_blank" rel="noopener nofollow">Tensorflow分布式原理理解</a></p>
<p><a href="https://www.jianshu.com/p/a5574ebcdeab" target="_blank" rel="noopener nofollow">TensorFlow架构与设计：概述</a></p>
<p><a href="https://blog.csdn.net/s_sunnyy/article/details/72830935" target="_blank" rel="noopener nofollow">Tensorflow 跨设备通信</a></p>
<p><a href="https://xie.infoq.cn/article/4857e469622b5d1aed9673bf8" target="_blank" rel="noopener nofollow">TensorFlow 篇 | TensorFlow 2.x 分布式训练概览</a></p>

</div>
<div class="clear"></div>
<div id="blog_post_info_block" role="contentinfo">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date" data-last-update-days="1123.1090671573506" data-date-created="BlogServer.Application.Dto.BlogPost.BlogPostDto" data-date-updated="2022-04-12 14:21">2022-04-12 14:21</span>&nbsp;
<a href="https://www.cnblogs.com/rossiXYZ">罗西的思考</a>&nbsp;
阅读(<span id="post_view_count">1493</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(16133750);return false;">收藏</a>&nbsp;
<a href="javascript:void(0)" onclick="reportManager.report({ currentUserId: '', targetType: 'blogPost', targetId: '16133750', targetLink: 'https://www.cnblogs.com/rossiXYZ/p/16133750.html', title: '[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇' })">举报</a>
</div>
        </div>
        <script>
    var cb_entryId = 16133750, cb_entryCreatedDate = '2022-04-12 14:21', cb_postType = 1, cb_postTitle = '[源码解析] TensorFlow 分布式 DistributedStrategy 之基础篇';
    var allowComments = true, cb_blogId = 556264, cb_blogApp = 'rossiXYZ', cb_blogUserGuid = '3d1961d5-3b13-4975-9d25-08d753a9a8fd';
    mermaidRender.render()
    markdown_highlight()
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");    
</script>
        <a id="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"> 
        <div class="comment-nav-right">
            <span id="span_refresh_tips"></span><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a>
        </div>
    </div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
        <div id="cnblogs_ch"></div>
    <div id="opt_under_post"></div>
        <div id="blog_c1" class="under-post-card">
            <a href="https://www.trae.com.cn/?utm_source=advertising&amp;utm_medium=cnblogs_ug_cpa&amp;utm_term=hw_trae_cnblogs" rel="nofollow" target="_blank" onclick="countCreativeClicks('C1-字节-trae')">
                <img src="https://img2024.cnblogs.com/blog/35695/202504/35695-20250422130943631-261509646.jpg" onload="countCreativeImpressions('C1-字节-trae')" alt="" />
                <span id="c1_impression" style="display:none"></span>
            </a>
        </div>
    <div id="under_post_card1"></div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
        var commentManager = new blogCommentManager();
        commentManager.renderComments(0);
        fixPostBody();
        window.footnoteTipManager.generateFootnoteTips();

            window.tocManager.displayDisableTocTips = false;
            window.tocManager.generateToc();
            
                setTimeout(function() { countViews(cb_blogId, cb_entryId); }, 50);
            
            deliverT2();
            deliverC1C2();
            loadNewsAndKb();
            
                LoadPostCategoriesTags(cb_blogId, cb_entryId);
            
            LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
            GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
            loadOptUnderPost();
            GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
                </script>
</div>

    </div>
</div>
            </div>
        </div>

        <div id="sideBar">
            <div id="sideBarMain">
                <div id="sidebar_news" class="newsItem">
    
<h3 class="catListTitle">公告</h3>
<div id="blog-news" class="sidebar-news">
    <div id="sidebar_news_container">
    </div>
</div>
<script>loadBlogNews();</script> 
</div>
<div id="sidebar_c3"></div>
                <div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                <script>loadBlogDefaultCalendar();</script>
                <div id="leftcontentcontainer">
                    <!-- begin:SingleColumn -->
                    <div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
                    <!-- end:  SingleColumn -->
                </div>
            </div>
        </div>
        <div class="clear"></div>
    </div>
    <div class="clear"></div>
    <div id="footer">
        <!--done-->
Copyright &copy; 2025 罗西的思考
<br /><span id="poweredby">Powered by .NET 9.0 on Kubernetes</span>

    </div>
</div>


    

    <input type="hidden" id="antiforgery_token" value="CfDJ8Ct_7-Gh-gZNte6RB_khjDoTisNQ4bqqn6kggRlfQcyaQnb18Udky5T3cQNvMFkukOUZM3W2zD_icaFPFd5a-W351aQKrKlnHMowmkRV0EBo_KAM6qHnFnGm8thidGQN1iZkzf1wKJG7M5Xn5h_xhFU" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-M95P3TTWJZ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-M95P3TTWJZ');
</script>
<script defer src="https://hm.baidu.com/hm.js?866c9be12d4a814454792b1fd0fed295"></script>
</body>
</html>
